name: "⚙️ Setup and Test"

on:
  workflow_call:
    inputs:
      docker_image:
        description: "The Docker image to use for the container"
        required: true
        type: string
      runs_on:
        description: "The runner to use for the job"
        required: true
        type: string
      test_group:
        description: "Array of test groups. Pass the array as a JSON string (e.g., '[1, 2, 3, 4, 5]')"
        required: true
        type: string

permissions:
  checks: write

jobs:
  setup-and-test:
    runs-on: ${{ inputs.runs_on }}
    timeout-minutes: 80
    strategy:
      fail-fast: false
      matrix:
        test_group: ${{ fromJSON(inputs.test_group) }}
    container:
      image: harbor.ci.tenstorrent.net/${{ inputs.docker_image }}
      options: "--rm --device /dev/tenstorrent"
    name: "🦄 Run tests (group ${{ matrix.test_group }}${{ fromJSON(inputs.test_group).length }})"
    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Install SFPI
      - name: Install SFPI
        shell: bash
        run: |
          cd tests
          ./setup_testing_env.sh
          cd ..

      # Step 3: Run the tests
      - name: Run tests
        id: run_tests
        continue-on-error: true  # Continue workflow even if tests fail
        shell: bash
        env:
          TEST_GROUPS: ${{ inputs.test_group }}
        run: |
          CHIP_ARCH=unknown
          if [[ "${{ inputs.runs_on }}" =~ n150 ]]; then
            CHIP_ARCH=wormhole
          elif [[ "${{ inputs.runs_on }}" =~ p150 ]]; then
            CHIP_ARCH=blackhole
          fi
          echo "CHIP_ARCH=$CHIP_ARCH" >> $GITHUB_ENV
          SPLITS=$(echo "$TEST_GROUPS" | jq '. | length')
          cd tests/python_tests/
          pytest -m "not perf" \
                --splits $SPLITS --group ${{ matrix.test_group }} \
                --override-ini="addopts=-v" --timeout=60 \
                --junitxml=pytest-report-${CHIP_ARCH}-${{ matrix.test_group }}.xml .

      # Step 4: Collect and compress test logs (only on test failure)
      - name: Collect test logs
        shell: bash
        if: failure() && steps.run_tests.outcome == 'failure'  # Only if tests failed
        run: |
          cd tests/python_tests/

          # Check if test_logs directory exists and has files
          if [ -d "test_logs" ] && [ "$(ls -A test_logs 2>/dev/null)" ]; then
            # Create timestamp and unique identifier for the archive file
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            ARCHIVE_NAME="test_logs_${CHIP_ARCH}_group${{ matrix.test_group }}_${TIMESTAMP}.tar.gz"

            echo "Tests failed - collecting test logs, creating archive: $ARCHIVE_NAME"

            # Create tar.gz archive with test logs
            tar -czf "$ARCHIVE_NAME" --exclude="*.tmp" --exclude="*.lock" test_logs/

            # Get some stats about the logs
            LOG_COUNT=$(find test_logs -name "*.log" | wc -l)
            ARCHIVE_SIZE=$(ls -lh "$ARCHIVE_NAME" | awk '{print $5}')

            echo "Compressed $LOG_COUNT log files into $ARCHIVE_NAME (size: $ARCHIVE_SIZE)"
            echo "LOG_ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV
            echo "LOG_COUNT=$LOG_COUNT" >> $GITHUB_ENV
            echo "ARCHIVE_SIZE=$ARCHIVE_SIZE" >> $GITHUB_ENV
          else
            echo "No test logs found in test_logs directory"
            echo "LOG_ARCHIVE_NAME=" >> $GITHUB_ENV
          fi

      # Step 5: Upload test logs as artifact (only on test failure)
      - name: Upload test logs
        uses: actions/upload-artifact@v4
        if: failure() && steps.run_tests.outcome == 'failure' && env.LOG_ARCHIVE_NAME != ''
        with:
          name: test-logs-${{ env.CHIP_ARCH }}-group${{ matrix.test_group }}-FAILED
          path: tests/python_tests/${{ env.LOG_ARCHIVE_NAME }}
          retention-days: 14  # Keep failure logs longer (14 days)
          compression-level: 0  # Already compressed

      # Step 6: Upload the JUnit report
      - name: Upload JUnit report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: junit-report-${{ env.CHIP_ARCH }}-${{ matrix.test_group }}
          path: tests/python_tests/pytest-report-${{ env.CHIP_ARCH }}-${{ matrix.test_group }}.xml

      # Step 7: Publish the test results
      - name: Publish Test Results
        uses: mikepenz/action-junit-report@v5
        if: always()
        with:
          report_paths: tests/python_tests/pytest-report-*-${{ matrix.test_group }}.xml
          include_passed: true
          annotate_only: true

      # Step 8: Fail the job if tests failed (after collecting logs)
      - name: Fail on test failure
        if: steps.run_tests.outcome == 'failure'
        run: |
          echo "Tests failed for group ${{ matrix.test_group }} on ${{ env.CHIP_ARCH }}"
          exit 1
