# Instruction types:
#   This field only matters for verilog generation, it signifies which hierarchical decoder "owns" instruction
#   LOCAL_CREGS  -
#   PC_MODIFYING -
#   COMPUTE      -
#   COMMON_CREGS - ???? Jel se ovo koristi? Nema ga us assembler.cpp
#
#
# Functional Coverage:
# --------------------------------------
#
# Auto-generated instruction-level FCOV is specified with the following three tags as commented in the example below.
#
#
# SOME_INSTR:
#   instrn_type: LOCAL_CREGS
#   ex_resource: SYNC
#   op_binary: 0xa0
#   fcov:                                  # This enables creation of the instruction specific FCOV group
#   arguments:
#       - name: mutex_index
#         start_bit: 0
#         field_type: HEX
#         description: &mutex_index >
#           Mutex index
#             0 - math
#             2 - unpack0
#             3 - unpack1
#             4 - pack0
#             5 - pack1
#             6 - pack2
#             7 - pack3
#         fcov_point_bins:                                   # This creates a coverage item for 'mutex_index' with the specified bins
#           bins: [ {name: "math",    value: "0x0"},
#                   {name: "unpack0",  value: "0x2"},
#                   {name: "unpack1",  value: "0x3"},
#                   {name: "pack0",    value: "0x4"},
#                   {name: "pack1",    value: "0x5"},
#                   {name: "pack2",  value: "0x6"},
#                   {name: "pack3",  value: "0x7"}]
#       - name: some_bin_interval_field                                          # This creates two bins, one for 0, and one for 1..10.  If 'slice' is smaller than the range, the range will be further divided into slices of that size
#         fcov_point_bin_interval:
#           bins: [ {name: "dst_0", slice: "1",  interval: ["0x0","0x0"]},
#                   {name: "dst_1", slice: "15", interval: ["0x1","0x10"]}]
#
#       - name: some_bool_field
#         fcov_point_bool:                                   # This creates a coverage item for 'some_bool_field' as a boolean.
#

ATGETM:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: ATOMICS
    op_binary: 0xa0
    fcov:
    arguments:
        - name: mutex_index
          start_bit: 0
          size: 24
          field_type: HEX
          description: &mutex_index >
              Mutex index
                0 - math
                2 - unpack0
                3 - unpack1
                4 - pack0
          fcov_point_bins:
            bins: [ {name: "math",     value: "0x0"},
                    {name: "unpack0",  value: "0x2"},
                    {name: "unpack1",  value: "0x3"},
                    {name: "pack0",    value: "0x4"}]
    description: >
        Acquires mutex with index `mutex_index' for the issuing
        thread. At most one thread can hold the mutex at any time.
        Returns immediately if, when the instruction starts, mutex is
        not held by any thread, or is held by the issuing thread.
        Otherwise, stalls issuing thread until mutex is acquired. When
        instruction completes, issuing thread holds the mutex, and it
        must be released using instruction ATRELM.

ATRELM:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: ATOMICS
    op_binary: 0xa1
    fcov:
    arguments:
        - name: mutex_index
          start_bit: 0
          size: 24
          field_type: HEX
          description: *mutex_index
          fcov_point_bins:
            bins: [ {name: "math",     value: "0x0"},
                    {name: "unpack0",  value: "0x2"},
                    {name: "unpack1",  value: "0x3"},
                    {name: "pack0",    value: "0x4"}]
    description: >
        Releases mutex with index `mutex_index' if it is held by
        issuing thread. Otherwise, has no effect.

STALLWAIT:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: OTHERS
    op_binary: 0xa2
    src_mask: 0x0
    fcov:
    arguments:
        - name: wait_res_idx_0
          start_bit: 0
          size: 5
          field_type: DEC
          description: >
           Resource to be waited for. This is an enum value to select one of the following options:
            0 - (nothing)
            1 - thcon
            2 - unpack0 idle
            3 - unpack0 L1 reads done (not currently supported)
            4 - unpack1 idle
            5 - unpack1 L1 reads done (not currently supported)
            6 - unpack2 idle
            7 - unpack2  L1 reads done (not currently supported)
            8 - pack0 idle
            9 - pack0 dest reads done (not currently supported)
           10 - pack1
           11 - pack1 dest reads done (not currently supported)
           12 - math
           13 - srcA clear
           14 - srcB clear
           15 - unpack to srcS rdy
           16 - pack srcS rdy
           17 - srcA valid
           18 - srcB valid
           19 - SFPU to srcS rdy
           20 - mover (deprecated?)
           21 - TRISC MMIO to CFG regs
           22 - SFPU
           23 - CfgExu
          fcov_point_bins:
            bins: [ {name: "nada",                value: "0x00"},
                    {name: "thcon",               value: "0x01"},
                    {name: "upk0_idle",           value: "0x02"},
                    {name: "upk0_l1_rds_done",    value: "0x03"},
                    {name: "upk1_idle",           value: "0x04"},
                    {name: "upk1_l1_rds_done",    value: "0x05"},
                    {name: "upk2_idl",            value: "0x06"},
                    {name: "upk2_l1_rds_done",    value: "0x07"},
                    {name: "pck0_idle",           value: "0x08"},
                    {name: "pck0_dst_rds_done",   value: "0x09"},
                    {name: "pck1_idle",           value: "0x0A"},
                    {name: "pck1_dst_rds_done",   value: "0x0B"},
                    {name: "math",                value: "0x0C"},
                    {name: "srcA_clr",            value: "0x0D"},
                    {name: "srcB_clr",            value: "0x0E"},
                    {name: "upk_srcS_rdy",        value: "0x0F"},
                    {name: "pck_srcS_rdy",        value: "0x10"},
                    {name: "srcA_vld",            value: "0x11"},
                    {name: "srcB_vld",            value: "0x12"},
                    {name: "sfpu_srcS_rdy",       value: "0x13"},
                    {name: "mover",               value: "0x14"},
                    {name: "trisc_mmio_cfg",      value: "0x15"},
                    {name: "sfpu",                value: "0x16"},
                    {name: "cfg_exu",             value: "0x17"} ]
        - name: wait_res_idx_1
          start_bit: 5
          size: 5
          field_type: DEC
          description: "resource to be waited for - see wait_res_idx_0 for enum codes"
          fcov_point_bins:
            bins: [ {name: "nada",                value: "0x00"},
                    {name: "thcon",               value: "0x01"},
                    {name: "upk0_idle",           value: "0x02"},
                    {name: "upk0_l1_rds_done",    value: "0x03"},
                    {name: "upk1_idle",           value: "0x04"},
                    {name: "upk1_l1_rds_done",    value: "0x05"},
                    {name: "upk2_idl",            value: "0x06"},
                    {name: "upk2_l1_rds_done",    value: "0x07"},
                    {name: "pck0_idle",           value: "0x08"},
                    {name: "pck0_dst_rds_done",   value: "0x09"},
                    {name: "pck1_idle",           value: "0x0A"},
                    {name: "pck1_dst_rds_done",   value: "0x0B"},
                    {name: "math",                value: "0x0C"},
                    {name: "srcA_clr",            value: "0x0D"},
                    {name: "srcB_clr",            value: "0x0E"},
                    {name: "upk_srcS_rdy",        value: "0x0F"},
                    {name: "pck_srcS_rdy",        value: "0x10"},
                    {name: "srcA_vld",            value: "0x11"},
                    {name: "srcB_vld",            value: "0x12"},
                    {name: "sfpu_srcS_rdy",       value: "0x13"},
                    {name: "mover",               value: "0x14"},
                    {name: "trisc_mmio_cfg",      value: "0x15"},
                    {name: "sfpu",                value: "0x16"},
                    {name: "cfg_exu",             value: "0x17"} ]
        - name: wait_res_idx_2
          start_bit: 10
          size: 5
          field_type: DEC
          description: "resource to be waited for - see wait_res_idx_0 for enum codes"
          fcov_point_bins:
            bins: [ {name: "nada",                value: "0x00"},
                    {name: "thcon",               value: "0x01"},
                    {name: "upk0_idle",           value: "0x02"},
                    {name: "upk0_l1_rds_done",    value: "0x03"},
                    {name: "upk1_idle",           value: "0x04"},
                    {name: "upk1_l1_rds_done",    value: "0x05"},
                    {name: "upk2_idl",            value: "0x06"},
                    {name: "upk2_l1_rds_done",    value: "0x07"},
                    {name: "pck0_idle",           value: "0x08"},
                    {name: "pck0_dst_rds_done",   value: "0x09"},
                    {name: "pck1_idle",           value: "0x0A"},
                    {name: "pck1_dst_rds_done",   value: "0x0B"},
                    {name: "math",                value: "0x0C"},
                    {name: "srcA_clr",            value: "0x0D"},
                    {name: "srcB_clr",            value: "0x0E"},
                    {name: "upk_srcS_rdy",        value: "0x0F"},
                    {name: "pck_srcS_rdy",        value: "0x10"},
                    {name: "srcA_vld",            value: "0x11"},
                    {name: "srcB_vld",            value: "0x12"},
                    {name: "sfpu_srcS_rdy",       value: "0x13"},
                    {name: "mover",               value: "0x14"},
                    {name: "trisc_mmio_cfg",      value: "0x15"},
                    {name: "sfpu",                value: "0x16"},
                    {name: "cfg_exu",             value: "0x17"} ]
        - name: stall_res
          start_bit: 15
          size: 9
          field_type: HEX
          description: "resource to be stalled -- bit mask for resources (compute/tdma(bit0), sync(bit1), pack(bit2), unpack(bit3), rsrvd, thcon(bit5), math(bit6), cfg(bit7), sfpu(bit8)  )"
          fcov_point_bins:
            bins: [ {name: "stall_compute/tdma",    value: "0x1"},
                    {name: "stall_sync",            value: "0x2"},
                    {name: "stall_pack",            value: "0x4"},
                    {name: "stall_unpack",          value: "0x8"},
                    {name: "stall_thcon",           value: "0x20"},
                    {name: "stall_math",            value: "0x40"},
                    {name: "stall_cfg",             value: "0x80"},
                    {name: "stall_sfpu",            value: "0x100"}]
    description: "Barrier instruction, stall resource until condition is met"

SEMINIT:
    description: "Initialize a semaphore"
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: OTHERS
    op_binary: 0xa3
    src_mask: 0x0
    fcov:
    arguments:
        - name: sem_sel
          start_bit: 0
          size: 8
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 or 8..15 select (see sem_bank_sel bit below)"
          fcov_point_bins:
            bins: [ {name: "semaphore0",  value: "0x1"},
                    {name: "semaphore1",  value: "0x2"},
                    {name: "semaphore2",  value: "0x4"},
                    {name: "semaphore3",  value: "0x8"},
                    {name: "semaphore4",  value: "0x10"},
                    {name: "semaphore5",  value: "0x20"},
                    {name: "semaphore6",  value: "0x40"},
                    {name: "semaphore7",  value: "0x80"}]
        - name: sem_bank_sel
          start_bit: 8
          size: 5
          field_type: BIN
          description: "The semaphores are divided into groups of 8; this selects the group. For example, if 0, this selects semaphores 0..7"
          fcov_point_bool:
        - name: init_value
          start_bit: 16
          size: 4
          field_type: DEC
          description: "Semaphore initial value [0..15]"
          fcov_point_bin_interval:
            bins: [ {name: "bot",      slice: "0x10000",  interval: ["0x0","0x0"]},
                    {name: "bot_half", slice: "0x10000",  interval: ["0x1","0x7"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x8","0xE"]},
                    {name: "top",      slice: "0x10000",  interval: ["0xF","0xF"]} ]
        - name: max_value
          start_bit: 20
          size: 4
          field_type: DEC
          description: "Semaphore max value [0..15]"
          fcov_point_bin_interval:
            bins: [ {name: "bot",      slice: "0x10000",  interval: ["0x0","0x0"]},
                    {name: "bot_half", slice: "0x10000",  interval: ["0x1","0x7"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x8","0xE"]},
                    {name: "top",      slice: "0x10000",  interval: ["0xF","0xF"]} ]

SEMPOST:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: OTHERS
    op_binary: 0xa4
    src_mask: 0x0
    fcov:
    arguments:
        - name: sem_sel
          start_bit: 0
          size: 8
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 or 8..15 select (see sem_bank_sel bit below)"
          fcov_point_bins:
            bins: [ {name: "semaphore0",  value: "0x1"},
                    {name: "semaphore1",  value: "0x2"},
                    {name: "semaphore2",  value: "0x4"},
                    {name: "semaphore3",  value: "0x8"},
                    {name: "semaphore4",  value: "0x10"},
                    {name: "semaphore5",  value: "0x20"},
                    {name: "semaphore6",  value: "0x40"},
                    {name: "semaphore7",  value: "0x80"}]
        - name: sem_bank_sel
          start_bit: 8
          # fixme: should this be 1-bit with an additional reserved field?
          size: 5
          field_type: BIN
          description: "The semaphores are divided into groups of 8; this selects the group. For example, if 0, this selects semaphores 0..7"
          fcov_point_bool:
    description: "Semaphore increment"

SEMGET:
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: OTHERS
    op_binary: 0xa5
    src_mask: 0x0
    fcov:
    arguments:
        - name: sem_sel
          start_bit: 0
          size: 8
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 or 8..15 select (see sem_bank_sel bit below)"
          fcov_point_bins:
            bins: [ {name: "semaphore0",  value: "0x1"},
                    {name: "semaphore1",  value: "0x2"},
                    {name: "semaphore2",  value: "0x4"},
                    {name: "semaphore3",  value: "0x8"},
                    {name: "semaphore4",  value: "0x10"},
                    {name: "semaphore5",  value: "0x20"},
                    {name: "semaphore6",  value: "0x40"},
                    {name: "semaphore7",  value: "0x80"}]
        - name: sem_bank_sel
          start_bit: 8
          # fixme: should this be 1-bit with an additional reserved field?
          size: 5
          field_type: BIN
          description: "The semaphores are divided into groups of 8; this selects the group. For example, if 0, this selects semaphores 0..7"
          fcov_point_bool:
    description: "Semaphore decrement"

SEMWAIT:
    description: "Semaphore barrier instruction, stall resource until semaphore condition is met"
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: OTHERS
    op_binary: 0xa6
    src_mask: 0x0
    fcov:
    arguments:
        - name: sem_sel
          start_bit: 0
          size: 8
          field_type: DEC
          description: "One-hot encoded semaphore 0..7 or 8..15 select (see sem_bank_sel bit below)"
          fcov_point_bins:
            bins: [ {name: "semaphore0",  value: "0x1"},
                    {name: "semaphore1",  value: "0x2"},
                    {name: "semaphore2",  value: "0x4"},
                    {name: "semaphore3",  value: "0x8"},
                    {name: "semaphore4",  value: "0x10"},
                    {name: "semaphore5",  value: "0x20"},
                    {name: "semaphore6",  value: "0x40"},
                    {name: "semaphore7",  value: "0x80"}]
        - name: sem_bank_sel
          start_bit: 8
          # fixme: should this be 1-bit with an additional reserved field?
          size: 5
          field_type: BIN
          description: "The semaphores are divided into groups of 8; this selects the group. For example, if 0, this selects semaphores 0..7"
          fcov_point_bool:
        - name: wait_sem_cond
          start_bit: 13
          size: 2
          field_type: DEC
          description: "Wait on semaphore. 1 - wait while semaphore is 0, 2 - wait while semaphore is max"
          fcov_point_bins:
            bins: [ {name: "WaitWhileZero",    value: "0x1"},
                    {name: "WaitWhileMax",     value: "0x2"}]
        - name: stall_res
          start_bit: 15
          size: 9
          field_type: HEX
          description: resource to be stalled -- bit mask for resources (compute/tdma, sync, pack, unpack, rsrvd, thcon, math, cfg, sfpu  )
          fcov_point_bins:
            bins: [ {name: "stall_compute/tdma",    value: "0x1"},
                    {name: "stall_sync",            value: "0x2"},
                    {name: "stall_pack",            value: "0x4"},
                    {name: "stall_unpack",          value: "0x8"},
                    {name: "stall_thcon",           value: "0x20"},
                    {name: "stall_math",            value: "0x40"},
                    {name: "stall_cfg",             value: "0x80"},
                    {name: "stall_sfpu",            value: "0x100"}]

WAIT_TILES:
    description: >
      Like STALLWAIT, but will wait for tile buffer buffer_sel to have at least
      num_tiles tiles available to read.
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: OTHERS
    op_binary: 0xa9
    fcov:
    arguments:
        - name: buffer_sel
          start_bit: 0
          size: 5
          field_type: DEC
          description: "Select which of the tile buffers to use. Valid values are 0-31 inclusive."
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: num_tiles
          start_bit: 5
          size: 10
          field_type: DEC
          description: "The resource(s) specified in stall_res will stall until this many tiles are available to read"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "0",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1FF"]},
                    {name: "top", slice: "0x100", interval: ["0x200","0x3FF"]}]
        - name: stall_res
          start_bit: 15
          size: 9
          field_type: HEX
          description: "resource to be stalled -- bit mask for resources (compute/tdma(bit0), sync(bit1), pack(bit2), unpack(bit3), rsrvd(bit4), thcon(bit5), math(bit6), cfg(bit7), sfpu(bit8)  )"
          fcov_point_bins:
            bins: [ {name: "stall_compute/tdma",    value: "0x1"},
                    {name: "stall_sync",            value: "0x2"},
                    {name: "stall_pack",            value: "0x4"},
                    {name: "stall_unpack",          value: "0x8"},
                    {name: "stall_thcon",           value: "0x20"},
                    {name: "stall_math",            value: "0x40"},
                    {name: "stall_cfg",             value: "0x80"},
                    {name: "stall_sfpu",            value: "0x100"}]

WAIT_FREE:
    description: >
      Like STALLWAIT, but will wait for tile buffer buffer_sel to have at least
      num_tiles tiles of space available to write.
    instrn_type: LOCAL_CREGS
    ex_resource: SYNC
    ttsync_resource: OTHERS
    op_binary: 0xab
    fcov:
    arguments:
        - name: buffer_sel
          start_bit: 0
          size: 5
          field_type: DEC
          description: "Select which of the tile buffers to use. Valid values are 0-31 inclusive."
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: num_tiles
          start_bit: 5
          size: 10
          field_type: DEC
          description: "The resource(s) specified in stall_res will stall until this much space is available to write"
          # fixme: add fcov.  What units is this in?
        - name: stall_res
          start_bit: 15
          size: 9
          field_type: HEX
          description: "resource to be stalled -- bit mask for resources (compute/tdma(bit0), sync(bit1), pack(bit2), unpack(bit3), rsrvd(bit4), thcon(bit5), math(bit6), cfg(bit7), sfpu(bit8)  )"
          fcov_point_bins:
            bins: [ {name: "stall_compute/tdma",    value: "0x1"},
                    {name: "stall_sync",            value: "0x2"},
                    {name: "stall_pack",            value: "0x4"},
                    {name: "stall_unpack",          value: "0x8"},
                    {name: "stall_thcon",           value: "0x20"},
                    {name: "stall_math",            value: "0x40"},
                    {name: "stall_cfg",             value: "0x80"},
                    {name: "stall_sfpu",            value: "0x100"}]

PUSH_TILES:
    op_binary: 0x3d
    ex_resource: PACK
    ttsync_resource: OTHERS # Pick a better class for this?
    instrn_type: TDMA
    arguments:
        - name: buffer_sel
          start_bit: 0
          size: 5
          field_type: DEC
          description: "Select which of the tile buffers to use. Valid values are 0-31 inclusive."
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: num_tiles
          start_bit: 5
          size: 10
          field_type: DEC
          description: "The number of tiles to add to the given buffer's tiles_posted counter"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",      interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x1000", interval: ["0x1","0x2FE"]},
                    {name: "top", slice: "0x1000", interval: ["0x2FF","0x3FF"]}]
        - name: packer_wr_done_wait_mask
          start_bit: 15
          size: 2
          field_type: BIN
          description: >
            Bit mask for {packer 1, packer 0}. If 1, this instruction will delay updating tiles_posted until the selected packer(s)
            are done writing. Specifically, this does NOT wait for the packer pipeline to flush, it only waits for older packer
            instructions to be finished writing to L1.
          fcov_point_bins:
            bins: [ {name: "v00",    value: "0x0"},
                    {name: "v01",    value: "0x1"},
                    {name: "v10",    value: "0x2"},
                    {name: "v11",    value: "0x3"} ]
    description: >
        Increment tiles_posted counter in buffer buffer_sel

POP_TILES:
    op_binary: 0x3e
    ex_resource: UNPACK
    ttsync_resource: OTHERS # Pick a better class for this?
    instrn_type: TDMA
    fcov:
    arguments:
        - name: buffer_sel
          start_bit: 0
          size: 5
          field_type: DEC
          description: "Select which of the tile buffers to use. Valid values are 0-31 inclusive."
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: num_tiles
          start_bit: 5
          size: 10
          field_type: DEC
          description: "The number of tiles to add to the given buffer's tiles_acked counter"
          # fixme: fcov
        - name: unpacker_rd_done_wait_mask
          start_bit: 15
          size: 3
          field_type: BIN
          # fixme: fcov
          description: >
            Bit mask for {unpacker 2, unpacker 1, unpacker 0}. If 1, this instruction will delay updating tiles_acked until the
            selected packer(s) are done writing. Specifically, this does NOT wait for the unpacker pipeline to flush, it only waits
            for older unpacker instructions to be finished reading from L1.
    description: >
        Increment tiles_acked counter in buffer buffer_sel

NOP:
    op_binary: 0x2
    ex_resource: NONE
    ttsync_resource: OTHERS
    instrn_type: PREDECODE
    src_mask: 0x0
    arguments: 0
    fcov:
    description: "Do nothing and consume an instruction slot and cycle"

MOVD2A:
    op_binary: 0x8
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments: &MOVD_REG
      - name: dst
        field_type: DEC
        start_bit: 0
        size: 11
        description: Dest address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
      - name: instr_mod
        field_type: DEC
        start_bit: 12
        size: 2
        description: "instruction modifier, 0 - move single row, 1 - move 4 rows, 2 - mov 8 rows"
        fcov_point_bins:
          bins: [ {name: "move_single_row", value: "0x0"},
                  {name: "move_4_rows",     value: "0x1"},
                  {name: "move_8_rows",     value: "0x2"}]
      - name: addr_mode
        field_type: BIN
        start_bit: 14
        size: 3
        description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        fcov_point_bin_interval:
          bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                  {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
      - name: src
        field_type: DEC
        start_bit: 17
        size: 6
        description: src address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x00","0x1F"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x20","0x3F"]} ]
      - name: dest_32b_lo
        field_type: BIN
        start_bit: 23
        size: 1
        description: address dest in 32-bit mode, but use the ext bits (Lower bits) (1-bit)
        fcov_point_bool:

    description: "Move dest register to srca. "

MOVD2B:
    op_binary: 0xA
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
      - name: dst
        field_type: DEC
        start_bit: 0
        size: 11
        description: Dest address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
      - name: transpose
        field_type: BIN
        start_bit: 11
        size: 1
        description: Indicates the data should be transposed when writing into srcB
        fcov_point_bool:
      - name: instr_mod
        field_type: DEC
        start_bit: 12
        size: 2
        description: "instruction modifier, 0 - move single row, 1 - move 4 rows, 2 - mov 8 rows"
        fcov_point_bins:
          bins: [ {name: "move_single_row", value: "0x0"},
                  {name: "move_4_rows",     value: "0x1"},
                  {name: "move_8_rows",     value: "0x2"}]
      - name: addr_mode
        field_type: BIN
        start_bit: 14
        size: 3
        description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        fcov_point_bin_interval:
          bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                  {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
      - name: src
        field_type: DEC
        start_bit: 17
        size: 6
        description: src address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x00","0x1F"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x20","0x3F"]} ]
      - name: dest_32b_lo
        field_type: BIN
        start_bit: 23
        size: 1
        description: address dest in 32-bit mode, but use the ext bits (Lower bits) (1-bit)
        fcov_point_bool:
    description: "Move dest register to srcb. "

MOVB2A:
    op_binary: 0xB
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments: &MOVB2A_REG
      - name: srcb
        field_type: DEC
        start_bit: 0
        size: 12
        description: Srcb address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x00","0x1F"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x20","0x3F"]} ]
      - name: instr_mod
        field_type: DEC
        start_bit: 12
        size: 2
        description: instruction modifier, 0 - move single row, 1 - move 4 rows, 2 - mov 8 rows
        fcov_point_bins:
          bins: [ {name: "move_single_row", value: "0x0"},
                  {name: "move_4_rows",     value: "0x1"},
                  {name: "move_8_rows",     value: "0x2"}]
      - name: addr_mode
        field_type: BIN
        start_bit: 14
        size: 3
        description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        fcov_point_bin_interval:
          bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                  {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
      - name: srca
        field_type: DEC
        start_bit: 17
        size: 7
        description: srca address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x00","0x1F"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x20","0x3F"]} ]
    description: "Move srcb register to srca. F"

ZEROACC:
    op_binary: 0x10
    ex_resource: INSTISSUE
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
        - name: where
          field_type: HEX
          start_bit: 0
          size: 14
          description: >
            Depending on clear_mode, selects the dest row(s) that will be affected. This field is 15 bits wide.
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "510", interval: ["0x1","0x1FE"]},
                    {name: "max", slice: "1",  interval: ["0x1FF","0x1FF"]} ]    # FIXME: these need to be updated
        - name: addr_mode
          field_type: BIN
          start_bit: 14
          size: 3
          description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
          fcov_point_bin_interval:
            bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                    {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
        - name: clear_zero_flags
          field_type: BIN
          start_bit: 17
          size: 1
          description: >
            Setting this to 1 causes the targeted zero flags to be cleared
            instead of set. In other words, dest data that was previously
            marked as zero will now be treated as initialized data.
          fcov_point_bool:
        - name: use_32_bit_mode
          field_type: BIN
          start_bit: 18
          size: 1
          description: "Set to 1 to use 32-bit addressing in dest"
          fcov_point_bool:
        - name: clear_mode
          field_type: BIN
          start_bit: 19
          size: 5
          description: >
            Clear modes:
            000 - Clear single row of datums. Uses current dest address from the counters plus the where field of this instruction.
            001 - Clear single face (i.e. 16 contiguous rows of datums) starting at dest row 16*where[7:0].
            010 - Clear half of dest. where[0] specifies which half (0 for lower, 1 for upper)
            011 - Clear all of dest.
          fcov_point_bins:
            bins: [ {name: "clear_only_specified_dest_row",                                     value: "0x0"},
                    {name: "dest_index_specifies_block_of_16_registers_to_clear",               value: "0x1"},
                    {name: "dest_index_specifies_upper_or_lower_half_to_clear",                 value: "0x2"},
                    {name: "clear_all_registers",                                               value: "0x3"} ]
    description: >
      Zero out accumulator. Single (00) mode clears one register and updates counters
      using the addressing mode. For other modes, zero-flags are set to emulate
      clearing of the dest memory, and dest_index is used to determine which portion
      is to be cleared.

      Note: bits 23:22 of this instruction are NOT available for future use; if they
      are nonzero, this instruction will cause srcA and/or srcB data valid to be
      cleared.

ZEROSRC:
    op_binary: 0x11
    ex_resource: INSTISSUE
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
        - name: src_mask
          field_type: DEC
          start_bit: 0
          size: 2
          description: 1 = zero out source A, 2 = zero out source B, 3 = zero out source A & B
          fcov_point_bins:
            bins: [ {name: "zero_out_source_A",       value: "0x1"},
                    {name: "zero_out_source_B",       value: "0x2"},
                    {name: "zero_out_source_A_and_B", value: "0x3"} ]
        - name: bank_mask
          field_type: DEC
          start_bit: 2
          size: 1
          description: 0 - zero out only current bank, 1 - zero out all banks
          fcov_point_bool:
        - name: write_mode
          field_type: DEC
          start_bit: 3
          size: 1
          description: 1 - current bank is the current read bank (i.e. math kernel), 0 - current bank is the current write bank (i.e. unpacker kernel)
          fcov_point_bool:
        - name: zero_val
          field_type: BIN
          start_bit: 4
          size: 1
          description: 0 - initialize registers with zero, 1 - initialize registers with -inf (all ones)
          fcov_point_bool:
        - name: exp_bias
          field_type: BIN
          start_bit: 5
          size: 1
          description: 0 - 5-bit exponent, 1 - 8-bit exponent  (Used only when zero_val is -inf)
          fcov_point_bool:
        - name: int_fmt
          field_type: BIN
          start_bit: 6
          size: 1
          description: 0 - floating point format, 1 - integer format (Used only when zero_val is -inf)
          fcov_point_bool:
        - name: packed_fmt
          field_type: BIN
          start_bit: 7
          size: 1
          description: 0 - unpacked format, 1 - packed MXFP4 or INT8 format (Used only when zero_val is -inf)
          fcov_point_bool:
    description: "Zero out source A or B registers"

MOVA2D:
    op_binary: 0x12
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x1
    fcov:
    arguments: &MOVA_REG
      - name: dst
        field_type: DEC
        start_bit: 0
        size: 11
        description: Dest address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x1FF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
      - name: instr_mod
        field_type: DEC
        start_bit: 12
        size: 2
        description: instruction modifier, 0 - move single row, 1 - move 4 rows, 2 - move 8 rows
        fcov_point_bins:
          bins: [ {name: "move_single_row", value: "0x0"},
                  {name: "move_4_rows",     value: "0x1"},
                  {name: "move_8_rows",     value: "0x2"}]
      - name: addr_mode
        field_type: BIN
        start_bit: 14
        size: 3
        description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        fcov_point_bin_interval:
          bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                  {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
      - name: src
        field_type: DEC
        start_bit: 17
        size: 6
        description: Src address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x1F"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x20","0x3F"]} ]
      - name: dest_32b_lo
        field_type: BIN
        start_bit: 23
        size: 1
        description: address dest in 32-bit mode, but use the ext bits (Lower bits) (1-bit)
        fcov_point_bool:

    description: "move srca register to dest"

MOVB2D:
    op_binary: 0x13
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x2
    fcov:
    arguments: &MOVB_REG
      - name: dst
        field_type: DEC
        start_bit: 0
        size: 11
        description: Dest address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
      - name: bcast_datum0
        field_type: BIN
        start_bit: 11
        size: 1
        description: If 1, the datum from column 0 will be broadcast to all 16 columns.
        fcov_point_bool:
      - name: transfer_sz
        field_type: DEC
        start_bit: 12
        size: 2
        description: >
            Number of rows to write into dest. All addresses must be aligned to a multiple of
            the transfer size. There is one exception: for transfer sizes > 1, we support a
            'row broadcast mode'. In this case, we will select a single row from srcB, but
            write it to n adjacaent rows in dest. This means the srcB address can be whatever,
            but the dest address must still be aligned. To select 'row broadcast mode', use the
            desired transfer size in this field, and set bit[0] of the dest address to 1. This
            is safe because for block transfers into dest the LSBs of the dest address are
            ignored (but we needed an extra bit in the MOVB2D instructions to select this mode,
            which is why it gets reused in this case).
            00 - 1 row
            01 - 4 rows
            10 - 8 rows
        fcov_point_bins:
          bins: [ {name: "move_single_row", value: "0x0"},
                  {name: "move_4_rows",     value: "0x1"},
                  {name: "move_8_rows",     value: "0x2"}]
      - name: addr_mode
        field_type: BIN
        start_bit: 14
        size: 3
        description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        fcov_point_bin_interval:
          bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                  {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
      - name: src
        field_type: DEC
        start_bit: 17
        size: 6
        description: Src address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x1F"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x20","0x3F"]} ]
      - name: dest_32b_lo
        field_type: BIN
        start_bit: 23
        size: 1
        description: address dest in 32-bit mode, but use the ext bits (Lower bits) (1-bit)
        fcov_point_bool:
    description: "move srcb register to dest"

MOVDBGA2D:
    op_binary: 0x9
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    fcov:
    src_mask: 0x0
    arguments: *MOVA_REG
    description: "move srca register to dest in debug mode - do not wait for ready signals"

MOVDBGB2D:
    op_binary: 0xC
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    fcov:
    src_mask: 0x0
    arguments: *MOVB_REG
    description: "move srcb register to dest in debug mode - do not wait for ready signals"


# This instruction was deprecated and replaced by the MOVD2B + transpose instruction
#TRNSPSRCB:
#    op_binary: 0x16
#    ex_resource: MATH
#    ttsync_resource: OTHERS
#    instrn_type: COMPUTE
#    src_mask: 0x2
#    arguments: 0
#    description: "XY transpose SRCB main registers rows[16:32]"

SHIFTXA:
    op_binary: 0x17
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x1
    fcov:
    arguments: &SRCA_SHIFTX
        - name: shift_mode
          field_type: DEC
          start_bit: 0
          size: 2
          description: 11 = combined row shift left towards column 0, 10 = combined row shift right away from column 0, 01 = reserved, 00 = reserved
          fcov_point_bins:
            bins: [ {name: "reserved1",                                        value: "0x0"},
                    {name: "reserved2",                                        value: "0x1"},
                    {name: "combined_row_shift_right_from_col0",              value: "0x2"},
                    {name: "combined_row_shift_left_to_col0",                 value: "0x3"} ]
        - name: log2_amount2
          field_type: DEC
          start_bit: 2
          size: 22
          description: Log2 of the shift amount - allowed only shift by 1
          fcov_point_bins:
            bins: [ {name: "shift_1", value: "0x0"} ]
    description: "horizontal SRCA shift"

SHIFTXB:
    op_binary: 0x18
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x2
    fcov:
    arguments: &SRCB_SHIFTX
        - name: shift_row
          field_type: DEC
          start_bit: 0
          size: 10
          description: addr row to be shifted
          fcov_point_bin_interval:
            bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x1F"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x20","0x3F"]} ]
        - name: rot_shift
          field_type: DEC
          start_bit: 10
          size: 4
          description: 0 = rotational shift (datum0 shifts out and feeds into datum15), 1 = non-rotational shift (datum0 shifts out and 0 feeds into datum15)
          fcov_point_bins:
            bins: [ {name: "rot_shift",     value: "0x0"},
                    {name: "non_rot_shift", value: "0x1"} ]
        - name: addr_mode
          field_type: BIN
          start_bit: 14
          size: 10
          fcov_point_bin_interval:
            bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                    {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
          description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
    description: "horizontal SRCB shift"


SETASHRMV:  #FIXME can we delete this?
    op_binary: 0x1C
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x1
    fcov:
    arguments: &SRCSHRV_MASK
        - name: reg_mask2
          field_type: HEX
          start_bit: 0
          size: 24
          description: 20bit wide register mask
    description: "SRCA right shift vertical mask, covering main reg_array and central_sr"

HALT:
    op_binary: 0x23
    ex_resource: NONE
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    arguments: 0
    description: "Halt the core and raise interrupt"

MVMULDI:
    op_binary: 0x25
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    fcov:
    arguments: &MVMULDI_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          size: 8
          description: Dest address spec
          fcov_point_bin_interval:
            bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
        - name: addr_mode
          field_type: BIN
          start_bit: 8
          size: 2
          description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
          fcov_point_bin_interval:
            bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                    {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
        - name: srca_addr
          field_type: DEC
          start_bit: 10
          size: 4
          description: srca_addr
          fcov_point_bin_interval:
            bins: [ {name: "srca_range", slice: "0x10000",  interval: ["0x0","0xF"]} ]

        - name: srcb_addr
          field_type: DEC
          start_bit: 14
          size: 4
          description: srcb_addr
          fcov_point_bin_interval:
            bins: [ {name: "srcb_range", slice: "0x10000",  interval: ["0x0","0xF"]} ]

        - name: ins_mod
          field_type: DEC
          start_bit: 18
          size: 3
          description: instruction modifier
          fcov_point_bins:
            bins: [ {name: "Full_BW",         value: "0x0"},
                    {name: "One_Fourth_BW",   value: "0x1"},
                    {name: "sparse",          value: "0x2"}]

        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          size: 2
          description: "Clear data valid bits (B,A) after math is done."
          fcov_point_bins:
            bins: [ {name: "cleardvalid_none", value: "0x0"},
                    {name: "cleardvalid_a", value: "0x1"},
                    {name: "cleardvalid_b", value: "0x2"},
                    {name: "cleardvalid_ab", value: "0x3"}]
    src_mask: 0x3
    description: "MVMUL with direct indexed srca/srcb "

MVMUL:
    op_binary: 0x26
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: &MVMUL_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          size: 14 # This field is unnecessarily large
          description: Dest address spec
          fcov_point_bin_interval:
            bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
        - name: addr_mode
          field_type: BIN
          start_bit: 14
          size: 5
          description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
          fcov_point_bin_interval:
            bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                    {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
        - name: instr_mod19
          field_type: DEC
          start_bit: 19
          size: 3
          description: instruction modifier, 0 - compute 4 rows (full BW); 1 - compute 1 row (1/4 of BW); 2 - sparse MVMUL (requires srcb metadata)
          fcov_point_bins:
            bins: [ {name: "Full_BW",         value: "0x0"},
                    {name: "One_Fourth_BW",   value: "0x1"},
                    {name: "sparse",          value: "0x2"}]
        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          size: 2
          description: "Clear data valid bits (B,A) after math is done."
          fcov_point_bins:
            bins: [ {name: "cleardvalid_none", value: "0x0"},
                    {name: "cleardvalid_a", value: "0x1"},
                    {name: "cleardvalid_b", value: "0x2"},
                    {name: "cleardvalid_ab", value: "0x3"}]
    description: "Vector-matrix multiply. Outputs 4x 16-wide row"

ELWMUL:
    op_binary: 0x27
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: &ELW_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          size: 14 # This field is unnecessarily large
          description: Dest address spec
          fcov_point_bin_interval:
            bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
        - name: addr_mode
          field_type: BIN
          start_bit: 14
          size: 5
          description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
          fcov_point_bin_interval:
            bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                    {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
        - name: instr_mod19
          field_type: DEC
          start_bit: 19
          size: 2
          description: instruction modifier, 0 - srcb no broadcast; 1 - srcb broadcast col0; 2 - broadcast row0; 3 - srcb broadcast both
          fcov_point_bins:
            bins: [ {name: "SRCB_NO_BCAST",          value: "0x0"},
                    {name: "SRCB_BCAST_COL",         value: "0x1"},
                    {name: "SRCB_BCAST_ROW",         value: "0x1"},
                    {name: "SRCB_BCAST_ROW_AND_COL", value: "0x3"}]
        - name: dest_accum_en
          field_type: BIN
          start_bit: 21
          size: 1
          description: If zero, dest value will be overwritten with math result. If 1, result is added to existing dest value.
          fcov_point_bool:
          # TODO: fcov stuff
        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          size: 2
          description: "Clear data valid bits (B,A) after math is done."
          fcov_point_bins:
            bins: [ {name: "cleardvalid_none", value: "0x0"},
                    {name: "cleardvalid_a", value: "0x1"},
                    {name: "cleardvalid_b", value: "0x2"},
                    {name: "cleardvalid_ab", value: "0x3"}]
    description: "Elementwise multiply operation"

ELWADD:
    op_binary: 0x28
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    fcov:
    src_mask: 0x3
    arguments: *ELW_ARGS
    description: "Elementwise add operation"


ELWSUB:
    op_binary: 0x30
    ex_resource: MATH
    ttsync_resource: OTHERS
    fcov:
    src_mask: 0x3
    instrn_type: COMPUTE
    arguments: *ELW_ARGS
    description: "Elementwise subtract operation (A-B)"
#ELWADDDI (dest[7:0], addr_mod[2:0], srcb_addr[3:0], srca_addr[3:0],  ins_mod[1:0], /*dest_accum[0]=0*/, clear_dvalid[1:0], switch_state_id) //24-bit
ELWADDDI:
    op_binary: 0x31
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: &ELWDI_ARGS
        - name: dst
          field_type: DEC
          start_bit: 0
          size: 8
          description: Dest address spec
          fcov_point_bin_interval:
            bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
        - name: addr_mode
          field_type: BIN
          start_bit: 8
          size: 2
          description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
          fcov_point_bin_interval:
            bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                    {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
        - name: srca_addr
          field_type: DEC
          start_bit: 10
          size: 4
          description: srca_addr
          fcov_point_bin_interval:
            bins: [ {name: "srca_range", slice: "0x10000",  interval: ["0x0","0xF"]} ]

        - name: srcb_addr
          field_type: DEC
          start_bit: 14
          size: 4
          description: srcb_addr
          fcov_point_bin_interval:
            bins: [ {name: "srcb_range", slice: "0x10000",  interval: ["0x0","0xF"]} ]

        - name: ins_mod
          field_type: DEC
          start_bit: 18
          size: 3
          description: instruction modifier - 0 - no broadcast; 1 - broadcast col0; 2 - broadcast row0; 3 - broadcast both
          fcov_point_bins:
            bins: [ {name: "NOBCAST_NODESTACCUM", value: "0x0"},
                    {name: "COL_BCAST_ONLY",  value: "0x1"},
                    {name: "ROW_BCAST_ONLY",  value: "0x2"},
                    {name: "SCALAR_BCAST_ONLY", value: "0x3"},
                    {name: "DEST_ACCUM_ONLY", value: "0x4"},
                    {name: "COL_BCAST_DEST_ACCUM", value: "0x5"},
                    {name: "ROW_BCAST_DEST_ACCUM", value: "0x6"},
                    {name: "SCALAR_BCAST_DEST_ACCUM", value: "0x7"}]

        - name: clear_dvalid
          field_type: BIN
          start_bit: 22
          size: 2
          description: "Clear data valid bits (B,A) after math is done."
          fcov_point_bins:
            bins: [ {name: "cleardvalid_none", value: "0x0"},
                    {name: "cleardvalid_a", value: "0x1"},
                    {name: "cleardvalid_b", value: "0x2"},
                    {name: "cleardvalid_ab", value: "0x3"}]
    description: "ELWADD with direct indexed srca/srcb "

ELWSUBDI:
    op_binary: 0x32
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: *ELWDI_ARGS
    description: "ELWSUB with direct indexed srca and srcb"

GMPOOL:
    op_binary: 0x33
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: &GPOOL_ARGS
      - name: dst
        field_type: DEC
        start_bit: 0
        size: 14 # This field is unnecessarily large
        description: Dest address spec
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0xFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x100","0x1FF"]} ]
      - name: max_pool_index_en
        field_type: DEC
        start_bit: 14
        size: 1
        description: Enable index computation for max pooling
        fcov_point_bool:
      - name: pool_addr_mode
        field_type: BIN
        start_bit: 15
        size: 4
        description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        fcov_point_bin_interval:
          bins: [ {name: "am_0_3", slice: "4",  interval: ["0x0","0x3"]},
                  {name: "am_4_7", slice: "4",  interval: ["0x4","0x7"]} ]
      - name: instr_mod19
        field_type: DEC
        start_bit: 19
        size: 3
        description: instruction modifier, 0 - single row wide; 1 - 16x16 wide
        fcov_point_bins:
          bins: [ {name: "single_row",     value: "0x0"},
                  {name: "16_x_16", value: "0x1"} ]
      - name: clear_dvalid
        field_type: BIN
        start_bit: 22
        size: 2
        description: "Clear data valid bits (B,A) after math is done."
        fcov_point_bins:
          bins: [ {name: "cleardvalid_none", value: "0x0"},
                  {name: "cleardvalid_a", value: "0x1"},
                  {name: "cleardvalid_b", value: "0x2"},
                  {name: "cleardvalid_ab", value: "0x3"}]
    description: "Global max pool with primitive size 16x16 "

GAPOOL:
    op_binary: 0x34
    ex_resource: MATH
    ttsync_resource: OTHERS
    src_mask: 0x3
    instrn_type: COMPUTE
    fcov:
    arguments: *GPOOL_ARGS
    description: "Global average pool with primitive size 16x16 "

SETDVALID:
    op_binary: 0x57
    ex_resource: TDMA
    ttsync_resource: OTHERS
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: setvalid
          field_type: BIN
          start_bit: 0
          size: 5
          description: "Set {S_packer, B_metadata, S_unpacker, B,A} data valid (5 bits)"
          fcov_point_bins:
            bins: [ {name: "vA", value: "0b00001"},
                    {name: "vB", value: "0b00010"},
                    {name: "vU", value: "0b00100"},
                    {name: "vM", value: "0b01000"},
                    {name: "vP", value: "0b10000"} ]
    description: "Sets A/B/S data valid for current write ID. TDMA instruction."

RV_PACR:
    op_binary: 0x35
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: reg_idx0
          field_type: BIN
          start_bit: 0
          size: 5
          description: "Specifies the first GPR register to return with the instruction"
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x10", interval: ["0x1","0x0e"]},
                    {name: "max", slice: "1",  interval: ["0xf","0xf"]} ]
        - name: reg_idx1
          field_type: BIN
          start_bit: 5
          size: 5
          description: "Specifies the second GPR register to return with the instruction"
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x10", interval: ["0x1","0x0e"]},
                    {name: "max", slice: "1",  interval: ["0xf","0xf"]} ]
        - name: reg_idx2
          field_type: BIN
          start_bit: 10
          size: 5
          description: "Specifies the third GPR register to return with the instruction"
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x10", interval: ["0x1","0x0e"]},
                    {name: "max", slice: "1",  interval: ["0xf","0xf"]} ]
    description: "PACK instruction which passes 3 GPR configuration registers with it
                  this instruction works only on the granularity of a whole tile;
                  GPR contents specifications are (format is {bit[31, bit[30...., bit[0]}):
                  GPR0 = { 3-bits   : Rows to untilize -> 3'b000 =  64
                                                          3'b001 =  32
                                                          3'b010 =  16
                                                          3'b011 =  8
                                                          3'b100 =  4
                                                          3'b101 =  2
                           18-bits  : L1 Addr of Tile (16B addr); for untilize this is 16-datum offset from Buffer base
                           10-bits  : Input (Dst/SrcS Regs) Addr (row addr)
                           1-bit    : Clear Dvalid
                         }
                  GPR1 = { 16-bits  : Stride for Untilize operation
                           8-bits   : Input Format
                           8-bits   : Tile format in L1}
                  GPR2 = { 1-bit    : Increment Output(L1) Tile Index
                           1-bit    : Increment Input(Dst/SrcS Regs) Tile Index
                           1-bit    : Calculate L1 Addr and Output Addr using Buffer Start Addr (GPR[1][24:7])
                                      and Tile Index Counter in HW instead of using Raw Addrs (GPR[0][17:0], and GPR[0][27:18]);
                           1-bit    : Perform Untilize operation
                           3-bits   : Tile Dim -> 3'b000 = 16x16x4
                                                  3'b001 = 16x16x1
                                                  3'b010 = 16x8x1
                                                  3'b011 = 16x4x1
                                                  3'b100 = 16x2x1
                                                  3'b101 = 16x1x1 (only for non-MX formats)
                           18-bits  : Start Addr of Buffer (16B addr)
                           2-bits   : Packer Sel ;  2'b00 = Packer[0]
                                                    2'b01 = Packer[1]
                                                    2'b1x = RESERVED}

                 "

PACR_STRIDE:
    op_binary: 0x1D
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 0
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: PackerSel
          field_type: BIN
          start_bit: 1
          size: 1
          description: "0 = Packer[0], 1 - Packer[1]"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: L1_16datums_Row_Index
          field_type: DEC
          start_bit: 7
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x3E"]},
                    {name: "top", slice: "1",     interval: ["0x3F","0x3F"]}]
          description: "6-bit L1 Start 16-datums-row Index; this is used to navigate within a tile"
        - name: Tile_Idx_Inc
          field_type: DEC
          start_bit: 13
          size: 1
          description: "When set L1_Tile_Idx_or_Tile_Idx_Inc field becomes Index Increment instead of absolute Index"
          fcov_point_bool:
        - name: L1_Tile_Idx_or_Tile_Idx_Inc
          field_type: DEC
          start_bit: 14
          size: 3
          description: "When Tile_Idx_Inc is not set this is L1 Tile Index
                        When Tile_Idx_Inc is set this is L1 Tile Index Increment to set up Tile Index for next PACR_STRIDE
                        When Tile_Idx_Inc is set the encoded values are
                        3'b000 = 1
                        3'b001 = 2
                        3'b010 = 4
                        3'b011 = 8
                        3'b100 = 16
                        3'b101 = 32
                        3'b110 = 64
                        3'b111 = 128"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",     interval: ["0x0","0x7"]} ]
        - name: Src_Row_Idx_Inc
          description: "If set, Src_Row_Idx_or_Inc_Mul4 become Index Increment instead of absolute Index
                        If set, value of 0 indicates Src_Row_Idx counter reset"
          field_type: DEC
          start_bit: 17
          size: 1
          fcov_point_bool:
        - name: Src_Row_Idx_or_Inc_Mul4
          description: "If Src_Row_Idx_Inc is not set ,6-bit Dest-Regs/Srcs Row-Idx; this is multiplied by 4 to get the Packer read row number;
                        If Src_Row_Idx_Inc is set, 6-bit Dest-Regs/Srcs Row-Idx Increment ; this is multiplied by 4 and incremented
                        to set up the Packer read row number for the next PACR instruction - If 0 or if ClrDatValid is set, the counter is reset;"
          field_type: DEC
          start_bit: 18
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1F"]},
                    {name: "top", slice: "0x100", interval: ["0x20","0x3F"]}]
    description: "Performs strided or random access unpacking of upto 4 16-datums rows;
                  Input Addresses have to be aligned to 4 rows;
                  this instruction is not supported for MX output format"

CLEARDVALID:
    op_binary: 0x36
    ex_resource: INSTISSUE
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments:
        - name: reset
          field_type: BIN
          start_bit: 0
          size: 2
          description: "bit 0: When set, clears all data valid bits, and reset write and read IDs to 0. Bit 1: Clear dvalid but dont switch bank"
          fcov_point_bool:
        - name: dest_pulse_last
          field_type: BIN
          start_bit: 2
          size: 4
          description: >
            Dest has four clients managed by hardware synchronization: unpack-to-dest, math, sfpu, and packer. This
            field has four bits, one per client (bit 0 = unpack-to-dest, bit 1 = math, bit 2 = sfpu, bit 3 = packer).
            Issue a CLEARDVALID instruction with some subset of these bits set to 1 to trigger the dvalid updates
            that would normally happen if an instruction of the corresponding type had set its `last` (or `done`)
            bit.
          fcov_point_bins:
            bins: [ {name: "unpack_to_dest",  value: "0x0"},
                    {name: "math",            value: "0x1"},
                    {name: "sfpu",            value: "0x2"},
                    {name: "packer",          value: "0x3"}]
        # The predecode is pulling bits 17:15 for the addr_mode index,
        # but CLEARDVALID doesn't use addr_mods
        - name: dest_dvalid_client_bank_reset
          field_type: BIN
          start_bit: 6
          size: 4
          description: Reset dest bank ID to 0 for given client bitmask (bit 0 = unpack-to-dest, bit 1 = math, bit 2 = sfpu, bit 3 = packer)
          fcov_point_bins:
            bins: [ {name: "unpack_to_dest",  value: "0x0"},
                    {name: "math",            value: "0x1"},
                    {name: "sfpu",            value: "0x2"},
                    {name: "packer",          value: "0x3"}]
        - name: dest_dvalid_reset
          field_type: BIN
          start_bit: 10
          size: 4
          description: Reset dest dvalid bit to 0 for given bitmask. This does not correspond to the clients, it corresponds to the four dvalid bits! Use 0xF if in doubt
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "14", interval: ["0x1","0xE"]},
                    {name: "max", slice: "1",  interval: ["0xF","0xF"]} ]
        - name: cleardvalid_S
          field_type: BIN
          start_bit: 20
          size: 2
          description: "Clear srcS data valid (2 bits). Bit 20 will clear the unpacker data_valid for srcS and bit 21 will clear the packer data_valid for srcS"
          fcov_point_bins:
            bins: [ {name: "clear_upk_data_valid_srcs",  value: "0x1"},
                    {name: "clear_pck_data_valid_srcs",  value: "0x2"}]
        - name: cleardvalid
          field_type: BIN
          start_bit: 22
          size: 2
          description: "Clear {B,A} data valid (2 bits)"
          fcov_point_bins:
            bins: [ {name: "cleardvalid_none", value: "0x0"},
                    {name: "cleardvalid_a", value: "0x1"},
                    {name: "cleardvalid_b", value: "0x2"},
                    {name: "cleardvalid_ab", value: "0x3"}]
    description: "Clear data valid bits, or reset data valid mechanism completely."

SETRWC:
    op_binary: 0x37
    ex_resource: MATH # Might make sense for this to be MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    arguments: &SETRWC_ARGS   # FIXME: fcov
        - name: BitMask
          field_type: BIN
          start_bit: 0
          size: 6
          description: "bit mask (SFPU SP, fidelity_phase_clear,rwc_d,rwc_b,rwc_a)"
          fcov_point_bins:
            bins: [ {name: "srcA",            value: "0x1"},
                    {name: "srcB",            value: "0x2"},
                    {name: "dest",            value: "0x4"},
                    {name: "fidelity_clear",  value: "0x8"},
                    {name: "sfpu_sp",         value: "0x10"}]
        - name: rwc_val
          field_type: DEC
          start_bit: 6
          size: 12
          description: Value to set for ALL counters named in the BitMask
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",    interval: ["0x0","0x0"]},
                    {name: "mid", slice: "4094", interval: ["0x1","0xFFE"]},
                    {name: "max", slice: "1",    interval: ["0xFFF","0xFFF"]} ]
        - name: rwc_cr
          field_type: BIN
          start_bit: 18
          size: 4
          description: "bit mask (apply values specified to RWC CR counters (Dest CToCRMode,Dest,SrcB,srcA) (Dest CToCrMode: 1: CR <= Counter + inc, 0: CR <= CR + inc)"
          fcov_point_bins:
            bins: [ {name: "DestCToCRMode", value: "0x8"},
                    {name: "Dest",          value: "0x4"},
                    {name: "SrcB",          value: "0x2"},
                    {name: "SrcA",          value: "0x1"} ]
        - name: clear_ab_vld
          field_type: BIN
          start_bit: 22
          size: 2
          description: clear srcA and srcB valids indicating to unpacker that new data can be written in
          fcov_point_bins:
            bins: [ {name: "cleardvalid_none", value: "0x0"},
                    {name: "cleardvalid_a", value: "0x1"},
                    {name: "cleardvalid_b", value: "0x2"},
                    {name: "cleardvalid_ab", value: "0x3"}]
    description: "Set register word counters or CR counters"

INCRWC:
    op_binary: 0x38
    ex_resource: MATH # Might make sense for this to be MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x0
    fcov:
    arguments: &INCRWC_ARGS
        - name: rwc_d
          field_type: DEC
          start_bit: 0
          size: 8
          description: Increment value to apply to dest counter
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",    interval: ["0x0","0x0"]},
                    {name: "mid", slice: "1022", interval: ["0x1","0x3FE"]},
                    {name: "max", slice: "1",    interval: ["0xFFF","0x3FF"]} ]
        - name: rwc_b
          field_type: DEC
          start_bit: 8
          size: 5
          description: Increment value to apply to srcb counter
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "30", interval: ["0x1","0x1E"]},
                    {name: "max", slice: "1",  interval: ["0x1F","0x1F"]} ]
        - name: rwc_a
          field_type: DEC
          start_bit: 13
          size: 5
          description: Increment value to apply to srcb counter
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "30", interval: ["0x1","0x1E"]},
                    {name: "max", slice: "1",  interval: ["0x1F","0x1F"]} ]
        - name: rwc_cr
          field_type: BIN
          start_bit: 18
          size: 6
          description: apply values specified to RWC CR counters
          fcov_point_bool:
    description: "Increment RWC counters or CR counters"

RV_UNPACR:
    # fixme: this will need custom fcov impl to cover over the GPR value as described below
    op_binary: 0x39
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: reg_idx0
          field_type: BIN
          start_bit: 0
          size: 5
          description: "Specifies the first GPR register to return with the instruction"
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x0e"]},
                    {name: "max", slice: "1",  interval: ["0xf","0xf"]} ]
        - name: reg_idx1
          field_type: BIN
          start_bit: 5
          size: 5
          description: "Specifies the second GPR register to return with the instruction"
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x0e"]},
                    {name: "max", slice: "1",  interval: ["0xf","0xf"]} ]
        - name: reg_idx2
          field_type: BIN
          start_bit: 10
          size: 5
          description: "Specifies the third GPR register to return with the instruction"
          fcov_point_bin_interval:
            bins: [ {name: "min", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x0e"]},
                    {name: "max", slice: "1",  interval: ["0xf","0xf"]} ]
    description: "Unpack instruction that passes 3 GPR configuration registers with it;
                  this instruction works only on the granularity of a whole tile;
                  GPR contents specifications are (format is {bit[31, bit[30...., bit[0]}):
                  GPR0 = { 3-bits   : Rows to tilize -> 3'b000 =  64
                                                        3'b001 =  32
                                                        3'b010 =  16
                                                        3'b011 =  8
                                                        3'b100 =  4
                                                        3'b101 =  2
                           18-bits  : L1 Addr of Tile (16B addr); for tilize this is 16-datum offset from Buffer base
                           10-bits  : Output (Src/Dst Regs) Addr (row addr)
                           1-bit    : Set Dvalid

                         }
                  GPR1 = { 16-bits  : Stride for Tilize operation
                           8-bits   : Output Format
                           8-bits   : Tile format in L1}
                  GPR2 = { 1-bit    : Increment Input(L1) Tile Index
                           1-bit    : Increment Output(Src/Dst Regs) Tile Index
                           1-bit    : Calculate L1 Addr and Output Addr using Buffer Start Addr (GPR[2][24:7])
                                      and Tile Index Counter in HW instead of using Raw Addrs (GPR[0][17:0], and GPR[0][27:18]);
                           1-bit    : Perform Tilize operation
                           3-bits   : Tile Dim -> 3'b000 = 16x16x4
                                                  3'b001 = 16x16x1
                                                  3'b010 = 16x8x1
                                                  3'b011 = 16x4x1
                                                  3'b100 = 16x2x1
                                                  3'b101 = 16x1x1 (only for non-MX formats)
                           18-bits  : Start Addr of Buffer (16B addr)
                           2-bits   : Unpacker Sel -> 2'b00 = Unpacker[0]
                                                      2'b01 = Unpacker[1]
                                                      2'b10 = Unpacker[2]
                                                      2'b11 = Unpack-to-Dst}

                 "

ELWMULDI:
    op_binary: 0x3A
    ex_resource: MATH
    ttsync_resource: OTHERS
    instrn_type: COMPUTE
    src_mask: 0x3
    fcov:
    arguments: *ELWDI_ARGS
    description: "ELWMUL with direct indexed srca and srcb"

PACR0_TILE:
    op_binary: 0xF
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx
          field_type: BIN
          start_bit: 7
          size: 9
          description: " 9-bit Src Tile Index"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x1000", interval: ["0x01","0x1FE"]},
                    {name: "top", slice: "0x1000",     interval: ["0x1FF","0x1FF"]}]  # fixme: getting binned further
        - name: Dst_Tile_Idx
          field_type: BIN
          start_bit: 16
          size: 8
          description: " 8-bit Dst Tile Index"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0xFF","0xFF"]}]  # fixme: this is getting binned further in the filter
    description: "Pack into L1 tile using Packer[0]"

PACR0_TILE_INC:
    op_binary: 0x19
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 9
          description: " 9-bit Src Tile Index Increment"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x1000", interval: ["0x01","0x1FE"]},
                    {name: "top", slice: "0x1000",     interval: ["0x1FF","0x1FF"]}]
        - name: Dst_Tile_Idx_Inc
          field_type: BIN
          start_bit: 16
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0xFF","0xFF"]}]
          description: " 8-bit Dst Tile Index Increment"
    description: "Pack into L1 tile with optional increments using Packer[0]"

PACR0_FACE:
    op_binary: 0x1F
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          description: "2-bit Dst Tile Face Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
    description: "Pack into L1 single face using Packer[0]"

PACR0_FACE_INC:
    op_binary: 0x20
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          description: "2-bit Dst Tile Face Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
    description: "Pack into L1 single face with optional increments using Packer[0]"


PACR0_ROW:
    op_binary: 0x2A
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          description: "2-bit Dst Tile Face Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Row_Idx
          field_type: BIN
          start_bit: 16
          size: 4
          description: "4-bit Src Tile Row Idx"
        - name: Dst_Row_Idx
          field_type: BIN
          start_bit: 20
          size: 4
          description: "4-bit Dst Tile Row Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
    description: "Pack into L1 single row using Packer[0]"

PACR0_ROW_INC:
    op_binary: 0x2B
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          description: "2-bit Dst Tile Face Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Row_Idx_Inc
          field_type: BIN
          start_bit: 16
          size: 4
          description: "4-bit Src Tile Row Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
        - name: Dst_Row_Idx_Inc
          field_type: BIN
          start_bit: 20
          size: 4
          description: "4-bit Dst Tile Row Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
    description: "Pack into L1 single row with optional increments using Packer[1]"

PACR1_TILE:
    op_binary: 0x2C
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx
          field_type: BIN
          start_bit: 7
          size: 9
          description: " 9-bit Src Tile Index"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Idx
          field_type: BIN
          start_bit: 16
          size: 8
          description: " 8-bit Dst Tile Index"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x7F"]},
                    {name: "top", slice: "0x100",     interval: ["0x80","0xFF"]}]
    description: "Pack into L1 tile using Packer[1]"

PACR1_TILE_INC:
    op_binary: 0x2D
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: " 9-bit Src Tile Index Increment"
        - name: Dst_Tile_Idx_Inc
          field_type: BIN
          start_bit: 16
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x7F"]},
                    {name: "top", slice: "0x100",     interval: ["0x80","0xFF"]}]
          description: " 8-bit Dst Tile Index Increment"
    description: "Pack into L1 tile with optional increments using Packer[1]"

PACR1_FACE:
    op_binary: 0x2E
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx"
    description: "Pack into L1 single face using Packer[1]"

PACR1_FACE_INC:
    op_binary: 0x2F
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
    description: "Pack into L1 single face with optional increments using Packer[1]"


PACR1_ROW:
    op_binary: 0x3B
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx"
        - name: Src_Row_Idx
          field_type: BIN
          start_bit: 16
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "4-bit Src Tile Row Idx"
        - name: Dst_Row_Idx
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Dst Tile Row Idx"
    description: "Pack into L1 single row using Packer[1]"

PACR1_ROW_INC:
    op_binary: 0x6E
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 9
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx Increment"
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
        - name: Src_Row_Idx_Inc
          field_type: BIN
          start_bit: 16
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Src Tile Row Idx Increment"
        - name: Dst_Row_Idx_Inc
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Dst Tile Row Idx Increment"
    description: "Pack into L1 single row with optional increments using Packer[1]"


PACR_UNTILIZE:
    op_binary: 0x42
    ex_resource: PACK
    ttsync_resource: PACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: ClrDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Packer will clear data valid bit for the registers it is Packing from"
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Packer_Sel
          field_type: BIN
          start_bit: 7
          size: 1
          description: "Packer Select
                        1'b0 = Packer[0]
                        1'b1 = RESERVED
                       "
          fcov_point_bool:
        - name: Src_Z_Cntr_inc
          field_type: BIN
          start_bit: 8
          size: 2
          description: " 2-bit Src Z-Cntr Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Z_Cntr_inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Dst Z-Cntr Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name : Cntr_Reset_mask
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Counter Reset Mask :
                         { Dst-Z-Cntr Reset,
                           Src-Z-Cntr Reset }"
        - name : Row_Cnt_Enc
          field_type: BIN
          start_bit: 14
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: " Number of rows to unpack :
                         3'b000 =  64
                         3'b001 =  32
                         3'b010 =  16
                         3'b011 =  8
                         3'b100 =  4
                         3'b101 =  2"
    description: "Untilizes faces in Dest Regs and write as flat layout in L1 - untilizes 4 16x16 faces in Dest;
                  This instruction is supported only in Packer[0]; This is not supported for Dest Strided Read Mode"


UNPACR0_TILE:
    op_binary: 0x3c
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx
          field_type: BIN
          start_bit: 7
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0xFF","0xFF"]}]
          description: " 8-bit Src Tile Index
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Tile_Idx
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0x3F","0x3F"]}]
          description: " 9-bit Dst Tile Index"
    description: "Unpack into SrcA Regs tile using Unpacker[0]"

UNPACR0_TILE_INC:
    op_binary: 0x44
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0xFF","0xFF"]}]
          description: " 8-bit Src Tile Index Increment"
        - name: Dst_Tile_Idx_Inc
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0x3F","0x3F"]}]
          description: " 9-bit Dst Tile Index Increment"
    description: "Unpack into SrcA Regs tile with optional increments using Unpacker[0]"

UNPACR0_FACE:
    op_binary: 0x47
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
    description: "Unpack into SrcA Regs single face using Unpacker[0]"

UNPACR0_FACE_INC:
    op_binary: 0x3f
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
    description: "Unpack into SrcA Regs single face with optional increments using Unpacker[0]"


UNPACR0_ROW:
    op_binary: 0x4B
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx"
        - name: Src_Row_Idx
          field_type: BIN
          start_bit: 16
          size: 4
          description: "4-bit Src Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
        - name: Dst_Row_Idx
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Dst Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
    description: "Unpack into SrcA Regs single row using Unpacker[0]"

UNPACR0_ROW_INC:
    op_binary: 0x4C
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx Increment"
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
        - name: Src_Row_Idx_Inc
          field_type: BIN
          start_bit: 16
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Src Tile Row Idx Increment"
        - name: Dst_Row_Idx_Inc
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Dst Tile Row Idx Increment"
    description: "Unpack into SrcA Regs single row with optional increments using Unpacker[0]"

RV_WRCFG:
    op_binary: 0x54
    ex_resource: CFG
    ttsync_resource: RV_WRCFG
    instrn_type: LOCAL_CREGS
    src_mask: 0x0
    fcov:
    arguments:
        - name: index_of_reg_containing_wrdata_lsbs
          field_type: BIN
          start_bit: 0
          size: 5
          description: "Number of the RISCV register containing the low 32 bits to write"
        - name: index_of_reg_containing_wrdata_msbs
          field_type: BIN
          start_bit: 5
          size: 5
          description: "Number of the RISCV register containing the high 32 bits to write"
        - name: index_of_reg_containing_cfg_index
          field_type: BIN
          start_bit: 10
          size: 5
          description: >
            Number of the RISCV register containing the CFG address (at a granularity of 32 bits,
            so that we can just use the same cfg_defines). When writing in 64-bit mode, the LSB of
            this value is ignored and all accesses are aligned to multiplied of 64 bits
        - name: write_64b
          field_type: BIN
          start_bit: 15
          size: 1
          description: >
            When 0, only write 32 bits, and only sample the low four bits of the byte_mask field. In
            this case, all bits of the given cfg index are used.
            When 1, write 64 bits, and sample all eight bits of the byte_mask field. In this case, the
            LSB of the cfg_index is ignored and all accesses will be aligned to 64 bits
        - name: byte_mask
          field_type: BIN
          start_bit: 16
          size: 8
          description: Per-byte write-enable for each of the bytes in 64-bit access
    description: "Write to Tensix CFG registers"

UNPACR1_TILE:
    op_binary: 0x5F
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx
          field_type: BIN
          start_bit: 7
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0xFF","0xFF"]}]
          description: " 8-bit Src Tile Index
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Tile_Idx
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0x3F","0x3F"]}]
          description: " 9-bit Dst Tile Index"
    description: "Unpack into SrcB Regs tile using Unpacker[1]"

UNPACR1_TILE_INC:
    op_binary: 0x69
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x7F"]},
                    {name: "top", slice: "0x100",     interval: ["0x80","0xFF"]}]
          description: " 8-bit Src Tile Index Increment"
        - name: Dst_Tile_Idx_Inc
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xFE"]},
                    {name: "top", slice: "0x100",     interval: ["0x3F","0x3F"]}]
          description: " 9-bit Dst Tile Index Increment"
    description: "Unpack into SrcB Regs tile with optional increments using Unpacker[1]"

UNPACR1_FACE:
    op_binary: 0x6A
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
    description: "Unpack into SrcB Regs single face using Unpacker[1]"

UNPACR1_FACE_INC:
    op_binary: 0x6B
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx Increment"
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
    description: "Unpack into SrcB Regs single face with optional increments using Unpacker[1]"


UNPACR1_ROW:
    op_binary: 0x6C
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Src_Row_Idx
          field_type: BIN
          start_bit: 16
          size: 4
          description: "4-bit Src Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
        - name: Dst_Row_Idx
          field_type: BIN
          start_bit: 20
          size: 4
          description: "4-bit Dst Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
    description: "Unpack into SrcB Regs single row using Unpacker[1]"

UNPACR1_ROW_INC:
    op_binary: 0x6D
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx Increment"
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
        - name: Src_Row_Idx_Inc
          field_type: BIN
          start_bit: 16
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Src Tile Row Idx Increment"
        - name: Dst_Row_Idx_Inc
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Dst Tile Row Idx Increment"
    description: "Unpack into SrcB Regs single row with optional increments using Unpacker[1]"

UNPACR2_TILE:
    op_binary: 0x9B
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: Src_Tile_Idx
          field_type: BIN
          start_bit: 7
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x7F"]},
                    {name: "top", slice: "0x100",     interval: ["0x80","0xFF"]}]
          description: " 8-bit Src Tile Index
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Tile_Idx
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: " 9-bit Dst Tile Index"
    description: "Unpack into SrcS Regs tile using Unpacker[2]"

UNPACR2_TILE_INC:
    op_binary: 0x9C
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: Src_Tile_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x7F"]},
                    {name: "top", slice: "0x100",     interval: ["0x80","0xFF"]}]
          description: " 8-bit Src Tile Index Increment"
        - name: Dst_Tile_Idx_Inc
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: " 9-bit Dst Tile Index Increment"
    description: "Unpack into SrcS Regs tile with optional increments using Unpacker[2]"

UNPACR2_FACE:
    op_binary: 0x9D
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
    description: "Unpack into SrcS Regs single face using Unpacker[2]"

UNPACR2_FACE_INC:
    op_binary: 0x9E
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          description: "2-bit Src Tile Face Idx Increment"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
    description: "Unpack into SrcS Regs single face with optional increments using Unpacker[2]"


UNPACR2_ROW:
    op_binary: 0x9F
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "2-bit Src Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "2-bit Dst Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Src_Row_Idx
          field_type: BIN
          start_bit: 16
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Src Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Row_Idx
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Dst Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
    description: "Unpack into SrcS Regs single row using Unpacker[2]"

UNPACR2_ROW_INC:
    op_binary: 0xA8
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx Increment"
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
        - name: Src_Row_Idx_Inc
          field_type: BIN
          start_bit: 16
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Src Tile Row Idx Increment"
        - name: Dst_Row_Idx_Inc
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          description: "4-bit Dst Tile Row Idx Increment"
    description: "Unpack into SrcS Regs single row with optional increments using Unpacker[2]"

UNPACR_DEST_TILE:
    op_binary: 0xAC
    ex_resource: UNPACK
    ttsync_resource: UNPACK # Use unpack0 for unpack-to-dest. TODO Does this make sense?
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx
          field_type: BIN
          start_bit: 7
          size: 8
          description: " 8-bit Src Tile Index
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x7F"]},
                    {name: "top", slice: "0x100",     interval: ["0x80","0xFF"]}]
        - name: Dst_Tile_Idx
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x1000", interval: ["0x01","0x1FE"]},
                    {name: "top", slice: "0x1000",     interval: ["0x1FF","0x1FF"]}]
          description: " 9-bit Dst Tile Index"
    description: "Unpack into SrcS Regs to Dest Regs tile using  Unpacker[0]"

UNPACR_DEST_TILE_INC:
    op_binary: 0xAD
    ex_resource: UNPACK
    ttsync_resource: UNPACK # Use unpack0 for unpack-to-dest. TODO Does this make sense?
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x7F"]},
                    {name: "top", slice: "0x100",     interval: ["0x80","0xFF"]}]
          description: " 8-bit Src Tile Index Increment"
        - name: Dst_Tile_Idx_Inc
          field_type: BIN
          start_bit: 15
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x1000", interval: ["0x01","0x1FE"]},
                    {name: "top", slice: "0x1000",     interval: ["0x1FF","0x1FF"]}]
          description: " 9-bit Dst Tile Index Increment"
    description: "Unpack to Dest Regs tile with optional increments using Unpacker[0]"

UNPACR_DEST_FACE:
    op_binary: 0xAE
    ex_resource: UNPACK
    ttsync_resource: UNPACK # Use unpack0 for unpack-to-dest. TODO Does this make sense?
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
    description: "Unpack to Dest Regs single face using Unpacker[0]"

UNPACR_DEST_FACE_INC:
    op_binary: 0xAF
    ex_resource: UNPACK
    ttsync_resource: UNPACK # Use unpack0 for unpack-to-dest. TODO Does this make sense?
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx Increment"
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          size: 2
          description: "2-bit Dst Tile Face Idx Increment"
    description: "Unpack to Dest Regs single face with optional increments using Unpacker[0]"


UNPACR_DEST_ROW:
    op_binary: 0xA7
    ex_resource: UNPACK
    ttsync_resource: UNPACK # Use unpack0 for unpack-to-dest. TODO Does this make sense?
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Face_Idx
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Src_Row_Idx
          field_type: BIN
          start_bit: 16
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x4"]} ]
          description: "4-bit Src Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
        - name: Dst_Row_Idx
          field_type: BIN
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "4-bit Dst Tile Row Idx
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
    description: "Unpack to Dest Regs single row using Unpacker[0]"

UNPACR_DEST_ROW_INC:
    op_binary: 0x65
    ex_resource: UNPACK
    ttsync_resource: UNPACK # Use unpack0 for unpack-to-dest. TODO Does this make sense?
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Src_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 7
          size: 3
          description: " 3-bit Tile Offset Index Increment :
                         3'b000 = 0
                         3'b001 = 1
                         3'b010 = 2
                         3'b011 = 4
                         3'b100 = 8
                         3'b101 = 16
                         3'b110 = 32
                         3'b111 = 64 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Dst_Tile_Offset_Idx_Inc
          field_type: BIN
          start_bit: 10
          size: 2
          description: " 2-bit Tile Offset Index Increment :
                         2'b00 = 0
                         2'b01 = 1
                         2'b10 = 2
                         2'b11 = 4 "
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_Face_Idx_Inc
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Src Tile Face Idx Increment"
        - name: Dst_Face_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2-bit Dst Tile Face Idx Increment"
        - name: Src_Row_Idx_Inc
          field_type: BIN
          start_bit: 16
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          size: 4
          description: "4-bit Src Tile Row Idx Increment"
        - name: Dst_Row_Idx_Inc
          field_type: BIN
          start_bit: 20
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0xF"]} ]
          size: 4
          description: "4-bit Dst Tile Row Idx Increment"
    description: "Unpack to Dest single row with optional increments using Unpacker[0]"

UNPACR_TILE_MISC:
    op_binary: 0xBF
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: Src_Tile_Idx
          field_type: BIN
          start_bit: 7
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0xF"]},
                    {name: "top", slice: "0x100",     interval: ["0x10","0x3F"]}]
          description: " 6-bit Src Tile Index
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo instead of using this field"
          # fixme: fcov
        - name: Dst_Tile_Idx
          field_type: BIN
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Dst Tile Index"
        - name: Tile_Idx_Inc
          field_type: BIN
          start_bit: 14
          size: 1
          fcov_point_bool:
          description: "If set Src_Tile_Idx and Dst_Tile_Idx fields are treated as increments instead of absolute indices"
          # fixme: fcov
        - name: Row_Bcast_Row_Idx
          field_type: BIN
          start_bit: 15
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x3E"]},
                    {name: "top", slice: "1",     interval: ["0x3F","0x3F"]}]
          description: " 6-bit Src Tile Row Index for SrcB row broadcast flavor
                         This row is broadcast into SrcB as a tile
                         IF ENABLE_ARG_FIFO reg is set, absolute idx is received from arg-fifo as {face_idx, row_idx}, instead of using this field"
        - name: Unpack_Type
          field_type: BIN
          start_bit: 21
          size: 3
          fcov_point_bin_interval:  # fixme: grade a p1/p2
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x2"]} ]
          description: "Unpack Type :
                        3'b000 = Unpack to Metadata Regs - uses Unpacker[0]; Unpacker In and Out formats need to be programmed to UINT8
                        3'b001 = Unpack to SrcA Regs with set stride - uses Unpacker[0]
                        3'b010 = Unpack to SrcB Regs with set stride - uses Unpacker[1]
                        3'b011 = Unpack to SrcA Regs with row broadcast - uses Unpacker[0]
                        3'b100 = Unpack to SrcB Regs with row broadcast - uses Unpacker[1]
                        3'b101 = Unpack to SrcS Regs with row broadcast - uses Unpacker[2]
                        3'b110 = Unpack to Dest Regs with row broadcast - uses Unpacker[0]"
    description: "Unpack tile for Metadata Regs, or with SrcA set stride or with SrcA/B/S row broadcast;
                  MODE1 of ARG_FIFO (ENABLE_ARG_FIFO with ARG_FIFO_MODE=1) is not supported for this instruction"

UNPACR0_STRIDE:
    op_binary: 0x6F
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: L1_16datums_Row_Index
          field_type: DEC
          start_bit: 7
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x3E"]},
                    {name: "top", slice: "1",     interval: ["0x3F","0x3F"]}]
          description: "6-bit L1 Start 16-datums-row Index; this is used to navigate within a tile"
        - name: Row_Mask_Reg_Sel
          field_type: DEC
          start_bit: 13
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "3-bit Select for the 8 Row Mask Regs, namely UNPACK_STRIDE_ROW_MASK<0/7>;
                        Bit-mask is on a per-row basis - if 1 mask is applied, else not"
        - name: Tile_Idx_Inc
          field_type: DEC
          start_bit: 16
          size: 1
          fcov_point_bool:
          description: "When set L1_Tile_Idx_or_Tile_Idx_Inc field becomes Index Increment"
        - name: L1_Tile_Idx_or_Tile_Idx_Inc
          field_type: DEC
          start_bit: 17
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "When Tile_Idx_Inc is not set this is L1 Tile Index
                        When Tile_Idx_Inc is set this is L1 Tile Index Increment to set up Tile Index for next UNPACR0_STRIDE
                        When Tile_Idx_Inc is set the encoded values are
                        3'b000 = 1
                        3'b001 = 2
                        3'b010 = 4
                        3'b011 = 8
                        3'b100 = 16
                        3'b101 = 32
                        3'b110 = 64
                        3'b111 = 128
                       "
        - name: Src_Reg_Y_Cntr_Incr
          field_type: DEC
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0xE"]},
                    {name: "top", slice: "1",     interval: ["0xF","0xF"]}]
          description: "4-bit Y Counter increment for Src Reg access for next UNPACR_STRIDE instruction;
                        Value of 0 resets the Y counter instead of performing any increment"
    description: "Performs strided or random access unpacking of upto 8 16-datums rows, into SrcA Regs using Unpacker[0]"

UNPACR1_STRIDE:
    op_binary: 0xAA
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: L1_16datums_Row_Index
          field_type: DEC
          start_bit: 7
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x3E"]},
                    {name: "top", slice: "1",     interval: ["0x3F","0x3F"]}]
          description: "6-bit L1 Start 16-datums-row Index; this is used to navigate within a tile"
        - name: Row_Mask_Reg_Sel
          field_type: DEC
          start_bit: 13
          size: 3
          description: "3-bit Select for the 8 Row Mask Regs, namely UNPACK_STRIDE_ROW_MASK<0/7>;
                        Bit-mask is on a per-row basis - if 1 mask is applied, else not"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Tile_Idx_Inc
          field_type: DEC
          start_bit: 16
          size: 1
          fcov_point_bool:
          description: "When set L1_Tile_Idx_or_Tile_Idx_Inc field becomes Index Increment"
        - name: L1_Tile_Idx_or_Tile_Idx_Inc
          field_type: DEC
          start_bit: 17
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "When Tile_Idx_Inc is not set this is L1 Tile Index
                        When Tile_Idx_Inc is set this is L1 Tile Index Increment to set up Tile Index for next UNPACR1_STRIDE
                        When Tile_Idx_Inc is set the encoded values are
                        3'b000 = 1
                        3'b001 = 2
                        3'b010 = 4
                        3'b011 = 8
                        3'b100 = 16
                        3'b101 = 32
                        3'b110 = 64
                        3'b111 = 128
                       "
        - name: Src_Reg_Y_Cntr_Incr
          field_type: DEC
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0xE"]},
                    {name: "top", slice: "1",     interval: ["0xF","0xF"]}]
          description: "4-bit Y Counter increment for Src Reg access for next UNPACR1_STRIDE instruction;
                        Value of 0 resets the Y counter instead of performing any increment"
    description: "Performs strided or random access unpacking of upto 8 16-datums rows, into SrcB Regs using Unpacker[1]"

UNPACR2_STRIDE:
    op_binary: 0x4E
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: L1_16datums_Row_Index
          field_type: DEC
          start_bit: 7
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x3E"]},
                    {name: "top", slice: "1",     interval: ["0x3F","0x3F"]}]
          description: "6-bit L1 Start 16-datums-row Index; this is used to navigate within a tile"
        - name: Row_Mask_Reg_Sel
          field_type: DEC
          start_bit: 13
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "3-bit Select for the 8 Row Mask Regs, namely UNPACK_STRIDE_ROW_MASK<0/7>;
                        Bit-mask is on a per-row basis - if 1 mask is applied, else not"

        - name: Tile_Idx_Inc
          field_type: DEC
          start_bit: 16
          size: 1
          fcov_point_bool:
          description: "When set L1_Tile_Idx_or_Tile_Idx_Inc field becomes Index Increment"
        - name: L1_Tile_Idx_or_Tile_Idx_Inc
          field_type: DEC
          start_bit: 17
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          size: 3
          description: "When Tile_Idx_Inc is not set this is L1 Tile Index
                        When Tile_Idx_Inc is set this is L1 Tile Index Increment to set up Tile Index for next UNPACR2_STRIDE
                        When Tile_Idx_Inc is set the encoded values are
                        3'b000 = 1
                        3'b001 = 2
                        3'b010 = 4
                        3'b011 = 8
                        3'b100 = 16
                        3'b101 = 32
                        3'b110 = 64
                        3'b111 = 128
                       "
        - name: Src_Reg_Y_Cntr_Incr
          field_type: DEC
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0xE"]},
                    {name: "top", slice: "1",     interval: ["0xF","0xF"]}]
          description: "4-bit Y Counter increment for Src Reg access for next UNPACR2_STRIDE instruction;
                        Value of 0 resets the Y counter instead of performing any increment"
    description: "Performs strided or random access unpacking of upto 8 16-datums rows, into SrcS Regs using Unpacker[2]"

UNPACR_DEST_STRIDE:
    op_binary: 0xBD
    ex_resource: UNPACK
    ttsync_resource: UNPACK # Use unpack0 for unpack-to-dest. TODO Does this make sense?
    instrn_type: TDMA
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
          description: "5-bit Tile Buffer Descriptor Table Select"
        - name: L1_16datums_Row_Index
          field_type: DEC
          start_bit: 7
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x3E"]},
                    {name: "top", slice: "1",     interval: ["0x3F","0x3F"]}]
          description: "6-bit L1 Start 16-datums-row Index; this is used to navigate within a tile"
        - name: Row_Mask_Reg_Sel
          field_type: DEC
          start_bit: 13
          size: 3
          description: "3-bit Select for the 8 Row Mask Regs, namely UNPACK_STRIDE_ROW_MASK<0/7>;
                        Bit-mask is on a per-row basis - if 1 mask is applied, else not"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Tile_Idx_Inc
          field_type: DEC
          start_bit: 16
          size: 1
          fcov_point_bool:
          description: "When set L1_Tile_Idx_or_Tile_Idx_Inc field becomes Index Increment"
        - name: L1_Tile_Idx_or_Tile_Idx_Inc
          field_type: DEC
          start_bit: 17
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "When Tile_Idx_Inc is not set this is L1 Tile Index
                        When Tile_Idx_Inc is set this is L1 Tile Index Increment to set up Tile Index for next UNPACR_DEST_STRIDE
                        When Tile_Idx_Inc is set the encoded values are
                        3'b000 = 1
                        3'b001 = 2
                        3'b010 = 4
                        3'b011 = 8
                        3'b100 = 16
                        3'b101 = 32
                        3'b110 = 64
                        3'b111 = 128
                       "
        - name: Src_Reg_Y_Cntr_Incr
          field_type: DEC
          start_bit: 20
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0xE"]},
                    {name: "top", slice: "1",     interval: ["0xF","0xF"]}]
          description: "4-bit Y Counter increment for Src Reg access for next UNPACR_DEST_STRIDE instruction;
                        Value of 0 resets the Y counter instead of performing any increment"
    description: "Performs strided or random access unpacking of upto 8 16-datums rows, into SrcA Regs using Unpacker[0]"

UNPACR_TILIZE:
    op_binary: 0xBE
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: SetDatValid
          field_type: BIN
          start_bit: 1
          size: 1
          description: "Unpacker will set data valid bit for the registers it is unpacking into once data has been written."
          fcov_point_bool:
        - name: Buffer_Descriptor_Table_Sel
          field_type: DEC
          start_bit: 2
          size: 5
          description: "5-bit Tile Buffer Descriptor Table Select"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x0","0x0"]},
                    {name: "mid", slice: "0x100", interval: ["0x1","0x1E"]},
                    {name: "top", slice: "1",     interval: ["0x1F","0x1F"]}]
        - name: Unpack_Sel
          field_type: BIN
          start_bit: 7
          size: 2
          description: "Unpacker Select
                        2'b00 = Unpack to SrcA Regs
                        2'b01 = Unpack to SrcB Regs
                        2'b10 = Reserved
                        2'b11 = Unpack to Dest Regs
                       "
        - name: Src_Z_Cntr_inc
          field_type: BIN
          start_bit: 9
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Src Z-Cntr Increment"
        - name : Dst_Z_Cntr_inc
          field_type: BIN
          start_bit: 11
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Dst Z-Cntr Increment"
        - name : Cntr_Reset_mask
          field_type: BIN
          start_bit: 13
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: " 2-bit Counter Reset Mask :
                         { Dst-Z-Cntr Reset,
                           Src-Z-Cntr Reset }"
        - name : Row_Cnt_Enc
          field_type: BIN
          start_bit: 15
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: " Number of rows to unpack :
                         3'b000 =  64
                         3'b001 =  32
                         3'b010 =  16
                         3'b011 =  8
                         3'b100 =  4
                         3'b101 =  2"
    description: "Tilizes 16x16x4 blocks/tiles in L1"


UNPACR_NOP: # Misc unpack instruction with side effect (skips actual search and unpack)
    op_binary: 0x43
    ex_resource: UNPACK
    ttsync_resource: UNPACK
    instrn_type: TDMA
    fcov:
    arguments:
        - name: Nop_type
          field_type: DEC
          start_bit: 0
          size: 2
          end_bit: 1
          description: >
                0 - UNP_CLR_SRC (clear srcA or srcB when unpack is done)
                1 - UNP_NOP (inject cycle delay between back to back unpack)
                2 - UNP_NOP_SETDAVLID (NOP in all respects except for setting Dvalid of Src Reg);
                    This will set the implied format for src regs with the value in the cfg reg UNPACKER<0/1>_REG0_OUT_DATA_FORMAT
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
        - name: Src_ClrVal_Ctrl
          field_type: DEC
          start_bit: 2
          size: 2
          end_bit: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: >
                Valid only for UNP_CLR_SRC
                  0 - clear to 0
                  1 - clear to neginf; format for neginf is determined based on the cfg-reg THCON_UNPACKER<0/1>_REG0_OUT_DATA_FORMAT
                  2 - Reserved
                  3 - Reserved
        -  name: Bank_Clr_Ctrl
           field_type: BIN
           start_bit: 4
           size: 1
           fcov_point_bool:
           description: >
               Valid only for UNP_CLR_SRC
                 0 - clear current bank
                 1 - clear all banks
        -  name: Stall_Cntrl
           field_type: BIN
           start_bit: 5
           size: 1
           fcov_point_bool:
           description: >
               Valid only for UNP_CLR_SRC and UNP_NOP_SETDAVLID
                 0 - stall until Data-Valid of the bank FPU is reading from goes low
                 1 - stall until Data-Valid of the bank Unpacker is going to write into goes low
        -  name: Set_Dvalid
           field_type: BIN
           start_bit: 7
           size: 1
           fcov_point_bool:
           description: >
               Valid only for UNP_CLR_SRC
                 Set Reg Bank Dvalid once clearing is done;
                 Also will set the implied format for src regs with the value in the cfg reg UNPACKER<0/1>_REG0_OUT_DATA_FORMAT
        - name: Unpacker_Select
          field_type: BIN
          start_bit: 8
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "Select between the 3 unpackers :
                        2'b00 = Unpacker[0]
                        2'b01 = Unpacker[1]
                        2'b1x = RESERVED"
    description: "Trigger side-effect once unpack is done. Skips actual search and unpack;
                  Supported only for SrcA(Unpacker[0]) and SrcB(Unpacker[1]"

SETGPR:
    op_binary: 0x45
    ex_resource: THCON
    ttsync_resource: GPR
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: GPR_Index16b
          field_type: DEC
          start_bit: 0
          size: 7
          description: "GPR index in 16b quants"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x7F","0x7F"]} ]
        - name: SetSignalsMode
          field_type: BIN
          start_bit: 7
          size: 1
          description: "Sets registers from signals routed into TDMA block rather than from payload immediate value specified in Payload_SigSel."
          fcov_point_bool:
        - name: Payload_SigSel
          field_type: DEC
          start_bit: 8
          size: 14
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x2"]},
                    {name: "top", slice: "0x1000000",     interval: ["0x3FFFF","0x3FFFF"]}]
          description: >
              SetSignalsMode == 0 : Immediate payload to set into selected register.
              SetSignalsMode == 1 : Payload selector
                                    0 : Max Exponent from Packer[0]
                                    1 : Min Exponent from Packer[0]
                                    2 : Max Exponent from Packer[1]
                                    3 : Min Exponent from Packer[1]
        - name: Payload_SigSelSize
          field_type: DEC
          start_bit: 22
          size: 2
          description: "Payload size in SetSignals mode. 0 - 16-bit, 1 - 32-bit, 2 - 128-bit"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
    description: "Set GPR file register with 16b immediate value provided with instruction or with routed signals from TDMA via indirect side-effects"


LOADIND:
    op_binary: 0x49
    ex_resource: THCON
    ttsync_resource: LDSTIND
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Addr_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          description: "Address register index. Address is a L1 16B address"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: Data_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          description: "Destination data register index"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: AutoIncSpec
          field_type: DEC
          start_bit: 12
          size: 2
          description: "Autoincrement spec: 0 - no autoinc, 1 - autoinc by 2(B)ytes, 2 - autoinc by 4B, 3 - autoinc by 16B"
          fcov_point_bins:
            bins: [ {name: "no_autoinc",     value: "0x0"},
                    {name: "autoinc_by_2B",  value: "0x1"},
                    {name: "autoinc_by_4B",  value: "0x2"},
                    {name: "autoinc_by_16B", value: "0x3"}]
        - name: OffsetIndex
          field_type: DEC
          start_bit: 14
          size: 8
          description: "Offset address register index, in 16b quants (i.e. double the normal R value). Offset is in Bytes
                        Value of 0 indicates no offset addition"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0xFF","0xFF"]} ]
        - name: SizeSel
          field_type: DEC
          start_bit: 22
          size: 2
          description: "Select whether the data move is 0 - 16B, 1 - 32b, 2 - 16b, 3 - 8b size"
          fcov_point_bins:
            bins: [ {name: "16B", value: "0x0"},
                    {name: "32b", value: "0x1"},
                    {name: "16b", value: "0x2"},
                    {name: "8b",  value: "0x3"}]
    description: "Load indirect from address specified in a GPR, with offset specified in GPR to a GPR. Supports autoincrementing offset;
                  Addresses have to be aligned to access sizes"

SET_SRC_TILE_FACE_ROW_IDX:
    op_binary: 0x6
    ex_resource: TDMA
    instrn_type: ADDRMOD
    ttsync_resource: OTHERS
    src_mask: 0x0
    fcov:
    arguments:
        - name: Value
          field_type: DEC
          start_bit: 0
          size: 18
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x3FFFE"]},
                    {name: "top", slice: "0x100000", interval: ["0x80","0x3FFFF"]}]
          description: "18-bit Set Value"
        - name: EngineSel
          field_type: BIN
          start_bit: 18
          size: 3
          description: "Engine selection :
                        3'b000 - Unpacker0
                        3'b001 - Unpacker1
                        3'b010 - Unpacker2
                        3'b011 - Packer0
                        3'b100 - Packer1
                        3'b101 - All Unpackers
                        3'b110 - All Packers
                        3'b111 - All Unpackers and Packers"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Tile_Face_Row_Sel
          field_type: BIN
          start_bit: 21
          size: 2
          description: "Mask :
                        2'b00 - Tile
                        2'b01 - Face
                        2'b10 - Row
                        2'b11 - Select all 3 of Tile, Face and Row"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
    description: "Set Src Tile/Face/Row Indices;
                  For Untilize/Tilize instructions, Face Idx is used as Z-Cntr"

INC_SRC_TILE_FACE_ROW_IDX:
    op_binary: 0x7
    ex_resource: TDMA
    ttsync_resource: OTHERS
    instrn_type: ADDRMOD
    src_mask: 0x0
    fcov:
    arguments:
        - name: Value
          field_type: DEC
          start_bit: 0
          size: 18
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x3FFFE"]},
                    {name: "top", slice: "0x100000", interval: ["0x80","0x3FFFF"]}]
          description: "18-bit Increment Value"
        - name: EngineSel
          field_type: BIN
          start_bit: 18
          size: 3
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
          description: "Engine selection :
                        3'b000 - Unpacker0
                        3'b001 - Unpacker1
                        3'b010 - Unpacker2
                        3'b011 - Packer0
                        3'b100 - Packer1
                        3'b101 - All Unpackers
                        3'b110 - All Packers
                        3'b111 - All Unpackers and Packers"
        - name: Tile_Face_Row_Sel
          field_type: BIN
          start_bit: 21
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "Mask :
                        2'b00 - Tile
                        2'b01 - Face
                        2'b10 - Row
                        2'b11 - Select all 3 of Tile, Face and Row"
    description: "Set Src Tile/Face/Row Indices;
                  For Untilize/Tilize instructions, Face Idx is used as Z-Cntr"

SET_DST_TILE_FACE_ROW_IDX:
    op_binary: 0xD
    ex_resource: TDMA
    ttsync_resource: OTHERS
    instrn_type: ADDRMOD
    src_mask: 0x0
    fcov:
    arguments:
        - name: Value
          field_type: DEC
          start_bit: 0
          size: 18
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x3FFFE"]},
                    {name: "top", slice: "0x100000", interval: ["0x80","0x3FFFF"]}]
          description: "18-bit Set Value"
        - name: EngineSel
          field_type: BIN
          start_bit: 18
          size: 3
          description: "Engine selection :
                        3'b000 - Unpacker0
                        3'b001 - Unpacker1
                        3'b010 - Unpacker2
                        3'b011 - Packer0
                        3'b100 - Packer1
                        3'b101 - All Unpackers
                        3'b110 - All Packers
                        3'b111 - All Unpackers and Packers"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Tile_Face_Row_Sel
          field_type: BIN
          start_bit: 21
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "Mask :
                        2'b00 - Tile
                        2'b01 - Face
                        2'b10 - Row
                        2'b11 - Select all 3 of Tile, Face and Row"
    description: "Set Dst Tile/Face/Row Indices;
                  For Untilize/Tilize instructions, Face Idx is used as Z-Cntr"

INC_DST_TILE_FACE_ROW_IDX:
    op_binary: 0xE
    ex_resource: TDMA
    ttsync_resource: OTHERS
    instrn_type: ADDRMOD
    src_mask: 0x0
    fcov:
    arguments:
        - name: Value
          field_type: DEC
          start_bit: 0
          size: 18
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",     interval: ["0x00","0x00"]},
                    {name: "mid", slice: "0x100", interval: ["0x01","0x3FFFE"]},
                    {name: "top", slice: "0x100000", interval: ["0x80","0x3FFFF"]}]
          description: "18-bit Increment Value"
        - name: EngineSel
          field_type: BIN
          start_bit: 18
          size: 3
          description: "Engine selection :
                        3'b000 - Unpacker0
                        3'b001 - Unpacker1
                        3'b010 - Unpacker2
                        3'b011 - Packer0
                        3'b100 - Packer1
                        3'b101 - All Unpackers
                        3'b110 - All Packers
                        3'b111 - All Unpackers and Packers"
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x7"]} ]
        - name: Tile_Face_Row_Sel
          field_type: BIN
          start_bit: 21
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "val", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "Mask :
                        2'b00 - Tile
                        2'b01 - Face
                        2'b10 - Row
                        2'b11 - Select all 3 of Tile, Face and Row"
    description: "Set Dst Tile/Face/Row Indices;
                  For Untilize/Tilize instructions, Face Idx is used as Z-Cntr"


ADDGPR:
    op_binary: 0x58
    ex_resource: THCON
    ttsync_resource: GPR
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments: &ADDGPR_ARGS
        - name: OpA_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          description: "32b GPR index for operand A"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x00","0x00"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: OpB_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x00","0x00"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "32b GPR index for operand B"
        - name: Result_GPR_Index
          field_type: DEC
          start_bit: 12
          size: 11
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x00","0x00"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "32b GPR index for result"
        - name: OpB_is_Const
          field_type: BIN
          start_bit: 23
          size: 1
          description: "Use OpB_GPR_Index as const value for math operation"
          fcov_point_bool:
    description: "If OpB_is_Const is 0 adds 32-bit values from GPRs pointed by OpA_GPR_Index and OpB_GPR_Index or
                  if OpB_is_Const is 1 adds 32-bit value from GPRs pointed by OpA_GPR_Index and 6-bit const value set in OpB_GPR_Index field
                  and writes result to register Result_GPR_Index"

SUBGPR:
    op_binary: 0x59
    ex_resource: THCON
    ttsync_resource: GPR
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments: *ADDGPR_ARGS
    description: "If OpB_is_Const is 0 subtracts 32-bit values from GPRs pointed by OpA_GPR_Index and OpB_GPR_Index
                  or if OpB_is_Const is 1 subtracts 32-bit value from GPR pointed by OpA_GPR_Index with 6-bit const value set in OpB_GPR_Index field
                  and writes result to register Result_GPR_Index"

MULGPR:
    op_binary: 0x5a
    ex_resource: THCON
    ttsync_resource: GPR
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments: *ADDGPR_ARGS
    description: "If OpB_is_Const is 0 multiplies 16-bit values from GPRs pointed by OpA_GPR_Index and OpB_GPR_Index or
                  if OpB_is_Const is 1 multiplies 16-bit value from GPR pointed by OpA_GPR_Index with 6-bit const value set in OpB_GPR_Index field
                  and writes result to register Result_GPR_Index"

BITWOPGPR:
    op_binary: 0x5b
    ex_resource: THCON
    ttsync_resource: GPR
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: OpA_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "32b GPR index for operand A"
        - name: OpB_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          description: "32b GPR index for operand B"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: Result_GPR_Index
          field_type: DEC
          start_bit: 12
          size: 6
          description: "32b GPR index for result"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: OpSel
          field_type: DEC
          start_bit: 18
          size: 5
          description: "0 - AND, 1 - OR, 2 - XOR"
          fcov_point_bins:
            bins: [ {name: "AND", value: "0x0"},
                    {name: "OR",  value: "0x1"},
                    {name: "XOR", value: "0x2"}]
        - name: OpB_is_Const
          field_type: BIN
          start_bit: 23
          size: 1
          fcov_point_bool:
          description: "Use OpB_GPR_Index as const value for math operation"
    description: "If OpB_is_Const is 0 performs bit-wise operation on 32-bit values from GPRs pointed by OpA_GPR_Index and OpB_GPR_Index or
                  if OpB_is_Const is 1 performs bit-wise operation on 32-bit value from GPR pointed by OpA_GPR_Index with 6-bit const value set in OpB_GPR_Index field
                  and writes result to register Result_GPR_Index"

SHIFTGPR:
    op_binary: 0x5c
    ex_resource: THCON
    ttsync_resource: GPR
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: OpA_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          description: "32b GPR index for operand A"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: OpB_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          description: "32b GPR index for operand B"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: Result_GPR_Index
          field_type: DEC
          start_bit: 12
          size: 6
          description: "32b GPR index for result"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: OpSel
          field_type: DEC
          start_bit: 18
          size: 5
          description: "0 - LEFT, 1 - RIGHT"
          fcov_point_bool:
        - name: OpB_is_Const
          field_type: BIN
          start_bit: 23
          size: 1
          description: "Use OpB_GPR_Index as const value for math operation"
          fcov_point_bool:
    description: "Shifts OpA_GPR_Index <<|>> OpB_GPR_Index and writes result to register Result_GPR_Index. If OpB_is_Const is 1 6-bit const value set in OpB_GPR_Index field is used as operand B"

CMPGPR:
    op_binary: 0x5d
    ex_resource: THCON
    ttsync_resource: GPR
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: OpA_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          description: "32b GPR index for operand A"
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
        - name: OpB_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "32b GPR index for operand B"
        - name: Result_GPR_Index
          field_type: DEC
          start_bit: 12
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "32b GPR index for result"
        - name: OpSel
          field_type: DEC
          start_bit: 18
          size: 5
          description: "0 - A>B, 1 - A<B, 2 - A==B"
          fcov_point_bins:
            bins: [ {name: "A_greater_than_B",  value: "0x0"},
                    {name: "A_less_than_B",  value: "0x1"},
                    {name: "A_equals_B", value: "0x2"}]
        - name: OpB_is_Const
          field_type: BIN
          start_bit: 23
          size: 1
          description: "Use OpB_GPR_Index as const value for math operation"
          fcov_point_bool:
    description: "Compares values in OpA_GPR_Index and OpB_GPR_Index registers and writes result 0 or 1 to register Result_GPR_Index. If OpB_is_Const is 1 6-bit const value set in OpB_GPR_Index field is used as operand B"

DMANOP:
    op_binary: 0x60
    ex_resource: THCON
    ttsync_resource: OTHERS
    src_mask: 0x0
    instrn_type: TDMA
    arguments: 0
    description: "Do nothing and consume an tdma instruction slot and cycle"

ATINCGET:
    op_binary: 0x61
    ex_resource: THCON
    ttsync_resource: ATOMICS
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Addr_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Address register index (16B word address)"
        - name: Data_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Destination data register index;
                        bits[11:8] are GPR address (16B granularity)
                        bits[7:6] are used to select the 32-bits of increment value from the 16B GPR data"
        - name: Sel32b
          field_type: DEC
          start_bit: 12
          size: 2
          description: "Selects the 32b word within a 16B word to operate on"
          fcov_point_bins:
            bins: [ {name: "word0", value: "0x0"},
                    {name: "word1", value: "0x1"},
                    {name: "word2", value: "0x2"},
                    {name: "word3", value: "0x3"}]
        - name: WrapVal
          field_type: DEC
          start_bit: 14
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0xF","0xF"]} ]
          description: "Wrap the targeted address value at 1 << WrapVal[4:0]"
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          size: 1
          description: "Selects whether transaction is targeting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: "Atomic increment and get - will read value in targeted memory location and return it to GPR and post-increment it atomically with the value pointed by Data_GPR_Index field"

ATINCGETPTR:
    op_binary: 0x62
    ex_resource: THCON
    ttsync_resource: ATOMICS
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Addr_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Address register index (16B word address)"
        - name: Data_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Destination data register index"
        - name: Sel32b
          field_type: DEC
          start_bit: 12
          size: 2
          description: "Selects the 32b word within a 16B word to operate on (i.e. Read/Write select)"
          fcov_point_bins:
            bins: [ {name: "word0", value: "0x0"},
                    {name: "word1", value: "0x1"},
                    {name: "word2", value: "0x2"},
                    {name: "word3", value: "0x3"}]
        - name: WrapVal
          field_type: DEC
          start_bit: 14
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0xF","0xF"]} ]
          description: "Wrap the targeted address value at 1 << WrapVal (e.g. Set WrapVal==3 for a 4-byte byte-addressed fifo)"
        - name: IncrVal
          field_type: DEC
          start_bit: 18
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0xF","0xF"]} ]
          description: "Post-increment by 1<<IncrVal if NoIncr is 0"
        - name: NoIncr
          field_type: BIN
          start_bit: 22
          size: 1
          description: "Disable pointer increment"
          fcov_point_bool:
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          size: 1
          description: "Selects whether transaction is targeting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: >
        Atomic increment and get pointer - will access a memory location designated as a FIFO pointer location (contains a 32b read pointer and a 32b write pointer), return the
        pointer value to GPR and post-increment it unless the FIFO condition precludes that. For example, write pointer will not be incremented if FIFO is full. Read pointer
        will not be incremented if FIFO is empty. FIFO full or empty conditions are returned as an unsuccessful return condition code, so that the thread controller can retry until
        success (retry reads if FIFO empty, retry writes if FIFO full.) If NoIncr is set to 1 then hardware will not increment the pointers but retry will still occur if FIFO is empty or full

ATSWAP:
    op_binary: 0x63
    ex_resource: THCON
    ttsync_resource: ATOMICS
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Addr_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Address register index (16B word address)"
        - name: Data_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 8
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "First of four data register indexes. Must be aligned to 4."
        - name: SwapMask
          field_type: DEC
          start_bit: 14
          size: 9
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0xFF","0xFF"]} ]
          description: "Swap mask at 16b granularity (8b of mask for 16B words)"
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          size: 1
          description: "Selects whether transaction is targeting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: "Atomic unconditional SWAP. Swaps selected 16b chunks of memory location with new ones provided on write data bus."

ATCAS:
    op_binary: 0x64
    ex_resource: THCON
    ttsync_resource: ATOMICS
    src_mask: 0x0
    instrn_type: TDMA
    fcov:
    arguments:
        - name: Addr_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Address register index (16B word address)"
        - name: Data_GPR_Index  # FIXME: unused and to be removed. Issue #434
          field_type: DEC
          start_bit: 6
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Destination data register index"
        - name: Sel32b
          field_type: DEC
          start_bit: 12
          size: 2
          description: "Selects the 32b word within a 16B word to operate on"
          fcov_point_bins:
            bins: [ {name: "word0", value: "0x0"},
                    {name: "word1", value: "0x1"},
                    {name: "word2", value: "0x2"},
                    {name: "word3", value: "0x3"}]
        - name: CmpVal
          field_type: DEC
          start_bit: 14
          size: 4
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Compare value provided as an immediate (4 bits)"
        - name: SwapVal
          field_type: DEC
          start_bit: 18
          size: 5
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Swap value provided as an immediate (4 bits)"
        - name: MemHierSel
          field_type: BIN
          start_bit: 23
          size: 1
          description: "Selects whether transaction is targeting DataRam (0) or L1 (1)"
          fcov_point_bool:
    description: >
        Atomic compare-and-swap. If value at selected memory location matches that provided by programmer it is swapped to a new one, also provided by
        programmer. Otherwise, instruction will be retried until it does match at which time it will swap.  This instruction is implemented for
        implementations of mutual exclusion between Tensix cores and threads

STOREIND:
    op_binary: 0x66
    ex_resource: THCON
    ttsync_resource: LDSTIND
    instrn_type: TDMA
    src_mask: 0x0
    fcov:
    arguments:
        - name: Addr_GPR_Index
          field_type: DEC
          start_bit: 0
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Index of GPR which contains the destination address"
        - name: Data_GPR_Index
          field_type: DEC
          start_bit: 6
          size: 6
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Index of GPR which contains the source data address"
        - name: AutoIncSpec
          field_type: DEC
          start_bit: 12
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "v", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "Autoincrement spec: 0 - no autoinc, 1 - autoinc by 2(B)ytes, 2 - autoinc by 4B, 3 - autoinc by 16B"
        - name: OffsetIndex
          field_type: DEC
          start_bit: 14
          size: 7
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          description: "Offset address register index - in 16b values
                        Value of 0 indicates no offset addition"
        - name: MemSel
          field_type: BIN
          start_bit: 21
          size: 1
          fcov_point_bool:
          description: "1'b0 = Write to MMIO space
                        1'b1 = Write to L1"
        - name: SizeSel
          field_type: BIN
          start_bit: 22
          size: 2
          fcov_point_bin_interval:
            bins: [ {name: "v", slice: "1",  interval: ["0x0","0x3"]} ]
          description: "2'b00 = 16B access
                        2'b01 = 32b access
                        2'b10 = 16b access  (for L1 only)
                        2'b11 = 8b access (for L1 only)"
          fcov_point_bool:
    description: "Store indirect. Stores data from GPR to memory location specified by a combination of base+offset provided in other GPRs. Supports auto-increment on offset value;
                  Addresses have to be aligned to access sizes"

STOREREG:
    op_binary: 0x67
    ex_resource: THCON
    ttsync_resource: STOREREG
    instrn_type: TDMA
    src_mask: 0x0
    arguments:
        - name: RegAddr
          field_type: DEC
          start_bit: 0
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3FFFF","0x3FFFF"]} ]
          size: 18
          description: "18-bit register index aligned to 32-bit"
        - name: Data_GPR_Index
          field_type: DEC
          start_bit: 18
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          size: 6
          description: "Source data register index"
    description: "Stores data from GPR to local RISC register space. Final register address is computed as 0xFFB0_0000 | (RegAddr<<2)"

LOADREG:
    op_binary: 0x68
    ex_resource: THCON
    ttsync_resource: LOADREG
    instrn_type: TDMA
    src_mask: 0x0
    arguments:
        - name: RegAddr  # Note: registers behind local reg arb
          field_type: DEC
          start_bit: 0
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3FFFF","0x3FFFF"]} ]
          size: 18
          description: "18-bit register index aligned to 32-bit"
        - name: Data_GPR_Index
          field_type: DEC
          start_bit: 18
          fcov_point_bin_interval:
            bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                    {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
          size: 6
          description: "Dest data register index"
    description: "Loads data from local RISC register space to GPR"

SFPLOAD:
    op_binary: 0x70
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: &SFPU_MEM
      - name: dest_reg_addr
        field_type: DEC
        start_bit: 0
        size: 11
        description: dest regs addr
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},    # 3FF
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]  # 400
      - name: done
        field_type: DEC
        start_bit: 11
        size: 1
        description: "For LOAD opcodes, switches the read bank for SRCS for subsequent LOADS. For STORE opcodes, switches the write bank for SRCS for subsequent STOREs. This bit should not be set when using Dest."
        fcov_point_bool:
      - name: sfpu_addr_mode
        field_type: BIN
        start_bit: 13
        size: 3
        description: 3-bit index of cfg register ADDR_MOD_REG to use for describing addressing mode
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x3"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x4","0x7"]} ]
      - name: instr_mod0
        field_type: DEC
        start_bit: 16
        size: 4
        description: >
            instruction modifier:
              DEFAULT       4'b0000
              FP16A         4'b0001
              FP16B         4'b0010
              FP32          4'b0011
              INT32         4'b0100
              INT32_COMP    4'b1100
              INT8          4'b0101
              INT8_COMP     4'b1101
              LO16          4'b0110
              LO16_ONLY     4'b1110
              HI16          4'b0111
              HI16_ONLY     4'b1111
        fcov_point_bins:  # fixme: filter at p2
          bins: [ {name: "def",         value: "0b0000"},
                  {name: "fp16a",       value: "0b0001"},
                  {name: "fp16b",       value: "0b0010"},
                  {name: "fp32",        value: "0b0011"},
                  {name: "int32",       value: "0b0100"},
                  {name: "int32_comp",  value: "0b1100"},
                  {name: "int8",        value: "0b0101"},
                  {name: "int8_comp",   value: "0b1101"},
                  {name: "lo16",        value: "0b0110"},
                  {name: "hi16",        value: "0b1111"} ]
      - name: lreg_ind
        field_type: DEC
        start_bit: 20
        size: 4
        description: lreg index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
    description: "sFPU load from dest regs"

SFPLOADI:
    op_binary: 0x71
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: &SFPU_MEMI
      - name: imm16
        field_type: DEC
        start_bit: 0
        size: 16
        description: immediate op
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]
      - name: instr_mod0
        field_type: DEC
        start_bit: 16
        size: 4
        description: instruction modifier   # FIXME: fcov
      - name: lreg_ind
        field_type: DEC
        start_bit: 20
        size: 4
        description: lreg index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
    description: "sFPU load immediate operand in half-float format"

SFPSTORE:
    op_binary: 0x72
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MEM
    description: "sFPU store to dest"

SFPLUT:
    op_binary: 0x73
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: &SFPU_LUT
      - name: dest_reg_addr
        field_type: DEC
        start_bit: 0
        size: 16
        description: dest regs addr
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]
      - name: instr_mod0
        field_type: DEC
        start_bit: 16
        size: 4
        # fixme: fcov
        description: instruction modifier
      - name: lreg_ind
        field_type: DEC
        start_bit: 20
        size: 4
        description: lreg index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
    description: "sFPU table look-up instruction; this is a two cycle operation "

SFPMULI:
    op_binary: 0x74
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: &SFPU_MATHI16
      - name: instr_mod1 # FIXME: fcov
        field_type: DEC
        start_bit: 0
        size: 4
        description: instruction modifier
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 4
        description: lreg dest index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: imm16_math
        field_type: DEC
        start_bit: 8
        size: 16
        description: immediate 16bit operand
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]
    description: "sFPU math instruction multiply-add with immediate operand in 12bit (exp/man) format; this is a two cycle operation "

SFPADDI:
    op_binary: 0x75
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI16  # fixme: fcov fixme from import
    description: "sFPU math instruction add with immediate 16bit operand; this is a two cycle operation "

SFPDIVP2:
    op_binary: 0x76
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: &SFPU_MATHI12
      - name: instr_mod1 # FIXME: fcov
        field_type: DEC
        start_bit: 0
        size: 4
        description: instruction modifier; for SFPAND and SPFOR when instrn_mod1[0] is set imm12_math[3:0] specifies lreg_b
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 4
        description: lreg dest index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_c
        field_type: DEC
        start_bit: 8
        size: 4
        description: lreg src_c index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: imm12_math
        field_type: DEC
        start_bit: 12
        size: 12
        description: immediate 12bit operand
        # fixme: fcov
    description: "sFPU math instruction ??"

SFPEXEXP:
    op_binary: 0x77
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12  # fixme: fcov from import
    description: "sFPU math instruction extend exponent"

SFPEXMAN:
    op_binary: 0x78
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12  # fixme: fcov from import
    description: "sFPU math instruction extend mantissa"

SFPIADD:
    op_binary: 0x79
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction ???"

SFPSHFT:
    op_binary: 0x7A
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    arguments: *SFPU_MATHI12  # fixme: fcov from import
    description: "sFPU math instruction shift"

SFPSETCC:
    op_binary: 0x7B
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12  # fixme: fcov from import
    description: "sFPU math instruction to manipulate conditional code"

SFPMOV:
    op_binary: 0x7C
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12  # fixme: fcov from import
    description: "sFPU math instruction move (imod[0]=1: invert sign)"

SFPABS:
    op_binary: 0x7D
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12  # fixme: fcov from import
    description: "sFPU math instruction absolute value"

SFPAND:
    op_binary: 0x7E
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction AND"

SFPOR:
    op_binary: 0x7F
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction OR"

SFPNOT:
    op_binary: 0x80
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction NOT"

SFPLZ:
    op_binary: 0x81
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import # fixme: fcov from import
    description: "sFPU math instruction find leading zeros"

SFPSETEXP:
    op_binary: 0x82
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction find leading zeros"

SFPSETMAN:
    op_binary: 0x83
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction find leading zeros"

SFPMAD:
    op_binary: 0x84
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: &SFPU_MATH
      - name: instr_mod1
        field_type: DEC
        start_bit: 0
        size: 4
        description: "instruction modifier :
                          bit[3] : use value in lreg[7][3:0] as a pointer to the destination lreg
                          bit[2] : use value in lreg[7][3:0] as a pointer to the src_a       lreg"
        # fixme: fcov
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 4
        description: lreg dest index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_src_c
        field_type: DEC
        start_bit: 8
        size: 4
        description: lreg src_c index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_src_b
        field_type: DEC
        start_bit: 12
        size: 4
        description: lreg src_b index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_src_a
        field_type: DEC
        start_bit: 16
        size: 8
        description: lreg src_a index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
    description: "sFPU math instruction multiply-add; this is a two cycle operation "

SFPADD:
    op_binary: 0x85
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATH # fixme: fcov from import
    description: "sFPU math instruction add; this is a two cycle operation  "

SFPMUL:
    op_binary: 0x86
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATH # fixme: fcov from import
    description: "sFPU math instruction multiply; this is a two cycle operation  "

SFPPUSHC:
    op_binary: 0x87
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU instruction to push CC flag to stack"

SFPPOPC:
    op_binary: 0x88
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU instruction to pop CC flag from stack and make it active"

SFPSETSGN:
    op_binary: 0x89
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction set sign"

SFPENCC:
    op_binary: 0x8A
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction to manipulate enable/disable"

SFPCOMPC:
    op_binary: 0x8B
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction to manipulate enable/disable"

SFPTRANSP:
    op_binary: 0x8C
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction transpose registers"

SFPXOR:
    op_binary: 0x8D
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction XOR"

SFP_STOCH_RND:
    op_binary: 0x8E
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments:
      - name: instr_mod1
        field_type: DEC
        start_bit: 0
        size: 4
        description: >
            instruction modifier bits [2:0]:
                fp32->fp16_a          - 0x0;
                fp32->fp16_b          - 0x1;
                fp32->unsigned  int8  - 0x2;
                fp32->signed    int8  - 0x3;
                int32->unsigned int8  - 0x4;
                int32->signed   int8  - 0x5;
                fp32->unsigned  int16 - 0x6;
                fp32->signed    int16 - 0x7;
                instruction modifier bit 3 : use immediate in place of srcb
        fcov_point_bins:
            bins: [ {name: "fp32_to_fp16_a",     value: "0x0"},
                    {name: "fp32_to_fp16_b",  value: "0x1"},
                    {name: "fp32_to_uint8",  value: "0x2"},
                    {name: "fp32_to_sint8", value: "0x3"},
                    {name: "int32_to_uint8", value: "0x4"},
                    {name: "int32_to_sint8", value: "0x5"},
                    {name: "fp32_to_uint16", value: "0x6"},
                    {name: "fp32_to_sint16", value: "0x7"}]
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 4
        description: lreg dest index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_src_c
        field_type: DEC
        start_bit: 8
        size: 4
        description: lreg src_c index - src_c provides the value to be rounded
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_src_b
        field_type: DEC
        start_bit: 12
        size: 4
        description: lreg src_b index - src_b[4:0] provides 5-bit descale value for rounding to int8
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: imm8_math
        field_type: DEC
        start_bit: 16
        size: 5
        description: immediate 8bit operand to provide descale value in place of src_b when instr_mod bit 3 is set
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: rnd_mode
        field_type: BIN
        start_bit: 21
        size: 3
        description: "Select the rounding mode - 0: Round to Nearest even; 1: Round Stochastically; 2: Round to zero"
        fcov_point_bins:
          bins: [ {name: "ne", value: "0x0"},
                  {name: "st", value: "0x1"},
                  {name: "tz", value: "0x2"} ]
    description: "sFPU math instruction to stochastically round a given value"

SFPNOP:
    op_binary: 0x8F
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments:
      - name: dest_done
        field_type: DEC
        start_bit: 0
        size: 1
        fcov_point_bool:
        description: indicates that SFPU operations for the current dest bank are done and the bank can be reused by the unpacker
      - name: srcs_rd_done
        field_type: DEC
        start_bit: 1
        size: 1
        fcov_point_bool:
        description: indicates that SFPU load operations for the current srcs bank are done and the bank can be reused by the unpacker
      - name: srcs_wr_done
        field_type: DEC
        start_bit: 2
        size: 1
        fcov_point_bool:
        description: indicates that SFPU store operations for the current srcs bank are done and the bank can be read by the packer
    description: "sFPU math instruction NOP"

SFPCAST:
    op_binary: 0x90
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments:
      - name: instr_mod1
        field_type: DEC
        start_bit: 0
        size: 4
        description: "instruction modifier :
                      int32 -> fp32 (nearest even)         - 0x0;
                      int32 -> fp32 (stochastically)       - 0x1;
                      int322s-> Sign Mag                   - 0x2;
                      int sign mag -> int32 2s             - 0x3;
                      RESERVED                             - 0xf : 0x4;"
        fcov_point_bins:
          bins: [ {name: "int32_to_fp32_neven",  value: "0x0"},
                  {name: "int32_to_fp32_stoch",  value: "0x1"},
                  {name: "int32_to_fsm",         value: "0x2"},
                  {name: "int32_sm_to_int32",    value: "0x3"} ]
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 4
        description: lreg dest index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_src_c
        field_type: DEC
        start_bit: 8
        size: 16
        description: lreg src_c index - src_c provides the value to be cast
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
    description: "sFPU math instruction to cast a given value into another format"

SFPCONFIG:
    op_binary: 0x91
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments:
      - name: instr_mod1  # fixme: fcov
        field_type: DEC
        start_bit: 0
        size: 4
        description: >
            instruction modifier :
              [0]        : if config_dest is     one of the constant_lregs, then setting this bit means to reset to the default value (write input is not used)
              [0]        : if config_dest is NOT one of the constant_lregs, then setting this bit means to use the imm16_math field as the write input value instead of lreg[0] as write input value
              [2:1] == 0 : if config_dest is SFPU or LOADMACRO Control Register, treat the write input as a normal write
              [2:1] == 1 : if config_dest is SFPU or LOADMACRO Control Register, treat the write input as an OR  MASK with the existing bits in the register (useful if you only want to SET    the values in specific bits while retaining whatever is in other bits)
              [2:1] == 2 : if config_dest is SFPU or LOADMACRO Control Register, treat the write input as an AND MASK with the existing bits in the register (useful if you only want to CLEAR  the values in specific bits while retaining whatever is in other bits)
              [2:1] == 3 : if config_dest is SFPU or LOADMACRO Control Register, treat the write input as an XOR MASK with the existing bits in the register (useful if you only want to INVERT the values in specific bits while retaining whatever is in other bits)
              [3]        : treat the imm16_math field as a column mask which will only enable the config update on the columns corresponding to bit positions which are 1 in the imm16_math field (note: bits [0] and [3] mean different uses for imm16_math)
      - name: config_dest  # fixme: fcov
        field_type: DEC
        start_bit: 4
        size: 4
        description: >
            SFPU configuration register index:
              Load Macro Instruction 0       : 0x0
              Load Macro Instruction 1       : 0x1
              Load Macro Instruction 2       : 0x2
              Load Macro Instruction 3       : 0x3
              Load Macro Sequence    0       : 0x4
              Load Macro Sequence    1       : 0x5
              Load Macro Sequence    2       : 0x6
              Load Macro Sequence    3       : 0x7
              Load Macro Control             : 0x8
              RESERVED                       : 0xA - 0x9
              Programmable constant lreg[11] : 0xB
              Programmable constant lreg[12] : 0xC
              Programmable constant lreg[13] : 0xD
              Programmable constant lreg[14] : 0xE
              SFPU Control Register          : 0xF
      - name: imm16_math
        field_type: DEC
        start_bit: 8
        size: 16
        description: immediate 16bit operand
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]
    description: "sFPU math instruction to program one of the configuration registers - hard-coded to read from LREG[0] on SFPU row[0] when not using the immediate field"

SFPSWAP:
    op_binary: 0x92  # fixme: fcov
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments:
      - name: instr_mod1
        field_type: DEC
        start_bit: 0
        size: 4
        description: >
            instruction modifier :
              Unconditionally swap the values in SRCC and DST                                                                  - 0x0
              DST will be written with the smaller value and SRCC with the larger value on all rows                            - 0x1
              DST will be written with the smaller value and SRCC with the larger value on rows 0 & 1 (opposite on other rows) - 0x2
              DST will be written with the smaller value and SRCC with the larger value on rows 0 & 2 (opposite on other rows) - 0x3
              DST will be written with the smaller value and SRCC with the larger value on rows 0 & 3 (opposite on other rows) - 0x4
              DST will be written with the smaller value and SRCC with the larger value on row  0     (opposite on other rows) - 0x5
              DST will be written with the smaller value and SRCC with the larger value on row  1     (opposite on other rows) - 0x6
              DST will be written with the smaller value and SRCC with the larger value on row  2     (opposite on other rows) - 0x7
              DST will be written with the smaller value and SRCC with the larger value on row  3     (opposite on other rows) - 0x8
              RESERVED                                                                                                         - 0xf : 0x9
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 4
        description: lreg dest index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: lreg_src_c
        field_type: DEC
        start_bit: 8
        size: 4
        description: lreg src_c index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
      - name: imm12_math
        field_type: DEC
        start_bit: 12
        size: 12
        description: immediate 12bit operand
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x000","0x7FF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x800","0xFFF"]} ]
    description: "sFPU math instruction to swap the values in two registers ; this is a two cycle operation"

SFPLOADMACRO:
    op_binary: 0x93
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MEM
    description: "sFPU load from dest regs and then run the macro specified in lreg_dest index[3:2]"

SFPSHFT2:
    op_binary: 0x94
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments:
      - name: instr_mod1  # FIXME: fcov
        field_type: DEC
        start_bit: 0
        size: 4
        description: >
            instruction modifier :
              (One cycle) shift LREGs[3:0] all rows in parallel left towards LREG[0]                       within the SFPU instance with all four rows of LREG[3] being written with zeros (type 0)                                                      - 0x0
              (One cycle) shift LREGs[3:0] all rows in series   left towards LREG[0] and up towards ROW[0] within the SFPU instance with only ROW[3]      LREG[3] being written with zeros (type 1)                                                      - 0x1
              (Two cycle) shift LREGs[3:0] all rows in parallel left towards LREG[0] locally within the SFPU and globally shift a single LREG from each row away from column 0 with LREG[src_c] of SFPU column X feeding into LREG[3] of SFPU column X+1 - 0x2
              (Two cycle) shift a single LREG from each row globally across SFPUs away from column 0 with LREG[src_c] of SFPU column X feeding into LREG[lreg_dest] of SFPU column X+1 with rotation                                                     - 0x3
              (Two cycle) shift a single LREG from each row globally across SFPUs away from column 0 with LREG[src_c] of SFPU column X feeding into LREG[lreg_dest] of SFPU column X+1 with zero fill on column 0                                        - 0x4
              (One cycle) normal bitwise shift within the LREG specified by lreg_dest by the amount specified in src_c                                                                                                                                   - 0x5
              (One cycle) normal bitwise shift within the LREG specified by lreg_dest by the amount specified in imm12_math                                                                                                                              - 0x6
              RESERVED                                                                                                                                                                                                                                   - 0xf : 0x7
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 4
        description: lreg dest index (doubles as src_b)
        fcov_point_bin_interval:
          bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                  {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
      - name: lreg_src_c
        field_type: DEC
        start_bit: 8
        size: 4
        description: lreg src_c index
        fcov_point_bin_interval:
          bins: [ {name: "bot", slice: "1",  interval: ["0x0","0x0"]},
                  {name: "top", slice: "1",  interval: ["0x3F","0x3F"]} ]
      - name: imm12_math
        field_type: DEC
        start_bit: 12
        size: 12
        description: immediate 12bit operand
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x000","0x7FF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x800","0xFFF"]} ]
    description: "sFPU shift2 instruction to shift LREGS across and within instances of the SFPU"

SFPLUTFP32:
    op_binary: 0x95
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: &SFPU_LUTFP32
      - name: instr_mod1  # fixme: fcov
        field_type: DEC
        start_bit: 0
        size: 4
        description: "instruction modifier :
                          4'b0000 : force lreg3 sign to zero on input to the MAD
                          4'b0100 : use lreg3 sign as the sign of the result on the MAD          "
        fcov_point_bins:
          bins: [ {name: "v0", value: "0b0000"},
                  {name: "v4", value: "0b0100"} ]
      - name: lreg_dest
        field_type: DEC
        start_bit: 4
        size: 20
        description: lreg dest index
        fcov_point_bins:
          bins: [ {name: "bot", value: "0x0"},
                  {name: "top", value: "0xF"} ]
    description: "sFPU table look-up instruction with FP32 precision; this is a two cycle operation "

SFPLE:
    op_binary: 0x96
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction less than b<=c "

SFPGT:
    op_binary: 0x97
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction less than b>c "

SFPMUL24:
    op_binary: 0x98
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATH # fixme: fcov from import
    description: "sFPU math instruction integer MUL24"

SFPARECIP:
    op_binary: 0x99
    ex_resource: SFPU
    ttsync_resource: OTHERS
    instrn_type: SFPU
    src_mask: 0x0
    fcov:
    arguments: *SFPU_MATHI12 # fixme: fcov from import
    description: "sFPU math instruction approximate reciprocal"


WRCFG:
    description: "Write configuration register of current thread's state with 32b data read from Gpr file"
    instrn_type: LOCAL_CREGS
    ex_resource: CFG
    ttsync_resource: WRCFG
    op_binary: 0xb0
    src_mask: 0x0
    fcov:
    arguments:
        - name: CfgReg
          start_bit: 0
          size: 15
          field_type: DEC
          description: "configuration register address to write data to (32-bit aligned)"
          fcov_point_bins:
            bins: [ {name: "bot", value: "0x0"},
                    {name: "top", value: "0xF"} ]
        - name: wr128b
          start_bit: 15
          size: 1
          field_type: DEC
          description: "Do 128-bit Reg to Cfg write if set to 1"
          fcov_point_bool:
        - name: GprAddress
          start_bit: 16
          size: 8
          field_type: DEC
          description: "gpr address to read data from (32-bit aligned)"
          # fixme: What's the valid range on this?  Should we split into GprAddressed and a reserved fld?

RDCFG:
    description: "Read configuration register of current thread's state and write to its from Gpr file"
    instrn_type: LOCAL_CREGS
    ex_resource: CFG
    ttsync_resource: RDCFG
    op_binary: 0xb1
    src_mask: 0x0
    fcov:
    arguments:
        - name: CfgReg
          start_bit: 0
          size: 16
          field_type: DEC
          description: "configuration register address to read data from (32-bit aligned)"
          fcov_point_bin_interval:
            bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]
        - name: GprAddress
          start_bit: 16
          size: 8
          field_type: DEC
          description: "gpr address to write config data to (32-bit aligned)"
          # fixme: What's the valid range on this?  Should we split into GprAddressed and a reserved fld?
          fcov_point_bin_interval:
            bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                    {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]

RMWCIB0:
  description: "Read-Modify-Write on Byte 0 of the cfg register, only updating the bits set in mask"
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xb2
  src_mask: 0x0
  fcov:
  arguments: &RMWCIB
      - name: Data
        start_bit: 0
        size: 8
        field_type: HEX
        description: DataToWrite (8-bits)
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x100",  interval: ["0x0","0x7F"]},
                  {name: "top_half", slice: "0x100",  interval: ["0x80","0xFF"]} ]
      - name: Mask
        start_bit: 8
        size: 8
        field_type: HEX
        description: Mask to use for data (8-bits)
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x100",  interval: ["0x0","0x7F"]},
                  {name: "top_half", slice: "0x100",  interval: ["0x80","0xFF"]} ]
      - name: CfgRegAddr
        start_bit: 16
        size: 8
        field_type: HEX
        description: Address of CFG register in active state space
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x100",  interval: ["0x0","0x7F"]},
                  {name: "top_half", slice: "0x100",  interval: ["0x80","0xFF"]} ]

RMWCIB0_BUT_ALIAS_BIT_8_OF_CFG_REG_ADDR_WITH_LSB_OF_OPCODE:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xb3 # = opcode(RMWCIB0) | 0b1
  src_mask: 0x0
  fcov:
  arguments:  *RMWCIB
  description: ";-)"

RMWCIB1:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xb4
  src_mask: 0x0
  fcov:
  arguments:  *RMWCIB
  description: "Read-Modify-Write on Byte 1 of the cfg register, only updating the bits set in mask"

RMWCIB1_BUT_ALIAS_BIT_8_OF_CFG_REG_ADDR_WITH_LSB_OF_OPCODE:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xb5 # = opcode(RMWCIB1) | 0b1
  src_mask: 0x0
  fcov:
  arguments:  *RMWCIB
  description: ";-)"

RMWCIB2:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xb6
  src_mask: 0x0
  fcov:
  arguments:  *RMWCIB
  description: "Read-Modify-Write on Byte 2 of the cfg register, only updating the bits set in mask"

RMWCIB2_BUT_ALIAS_BIT_8_OF_CFG_REG_ADDR_WITH_LSB_OF_OPCODE:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xb7 # = opcode(RMWCIB2) | 0b1
  src_mask: 0x0
  fcov:
  arguments:  *RMWCIB
  description: ";-)"

RMWCIB3:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: OTHERS
  op_binary: 0xb8
  src_mask: 0x0
  fcov:
  arguments:  *RMWCIB
  description: "Read-Modify-Write on Byte 3 of the cfg register, only updating the bits set in mask"

RMWCIB3_BUT_ALIAS_BIT_8_OF_CFG_REG_ADDR_WITH_LSB_OF_OPCODE:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xb9 # = opcode(RMWCIB3) | 0b1
  src_mask: 0x0
  fcov:
  arguments:  *RMWCIB
  description: ";-)"

CFGSHIFTMASK:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xba
  fcov:
  arguments: &CFGSHIFTMASK
      - name: scratch_sel
        start_bit: 0
        size: 2
        field_type: BIN
        description: >
            Each CFGSHIFTMASK has two operands: one is selected by the CfgReg field
            (this also selects the output location) and the other is one of the three
            SCRATCH register in global config. This field selects one of the three, or
            you can use 0b11 to mean 'select based on my thread ID'
        fcov_point_bins:
          bins: [ {name: "v00",    value: "0x0"},
                  {name: "v01",    value: "0x1"},
                  {name: "v10",    value: "0x2"},
                  {name: "v11",    value: "0x3"} ]
      - name: right_cshift_amt
        start_bit: 2
        size: 5
        field_type: DEC
        description: "Number of places for the circular right shift (0-31). See CFGSHIFTMASK instruction description for details"
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x100",  interval: ["0x0", "0x0F"]},
                  {name: "top_half", slice: "0x100",  interval: ["0x10","0x1F"]} ]
      - name: mask_width
        start_bit: 7
        size: 5
        field_type: DEC
        description: "Width of mask minus one. In other words, if you want a mask of width N, put N-1 in this field. See CFGSHIFTMASK instruction description for details"
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x100",  interval: ["0x0", "0x0F"]},
                  {name: "top_half", slice: "0x100",  interval: ["0x10","0x1F"]} ]
      - name: operation
        start_bit: 12
        size: 3
        field_type: DEC
        description: >
            Select operation.
              000: old OR scratch
              001: old AND scratch
              010: old XOR scratch
              011: old + scratch
              100: old OR ~scratch (don't know why this would ever be useful but hey it's there)
              101: old AND ~scratch (don't know why this would ever be useful but hey it's there)
              110: old XOR ~scratch (don't know why this would ever be useful but hey it's there)
              111: old - scratch
            Note that addition can carry outside of the given mask.
        fcov_point_bins:
          bins: [ {name: "or_scratch", value: "0b000"},
                  {name: "and_scratch", value: "0b001"},
                  {name: "xor_scratch", value: "0b010"},
                  {name: "pls_scratch", value: "0b011"},
                  {name: "or_not_scratch", value: "0b100"},
                  {name: "and_not_scratch", value: "0b101"},
                  {name: "xor_not_scratch", value: "0b110"},
                  {name: "minus_scratch", value: "0b111"} ]
      - name: disable_mask_on_old_val
        start_bit: 15
        size: 1
        field_type: BIN
        description: >
            The final calculation is op(scratch_shifted & mask, old_val & ~mask),
            where old_val was the original value in CfgReg before we edited it
            with this instruction. However, if you set this bit to 1, the old_val
            will not be masked.
        fcov_point_bool:
      - name: CfgRegAddr
        start_bit: 16
        size: 8
        field_type: DEC
        description: "configuration register address to write data to (32-bit aligned)"
        # fixme: should this really be 8-bits?
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]

  description: >
    This instruction performs a mask and a shift on a 'CFG scratch register'
    (explained below) and saves the result in the CFG register indicated by the
    CfgReg argument.

    This instruction takes two cycles to complete. It is not necessary to
    place NOPs in between two CFGSHIFTMASK instructions. Actually, you
    never need to place NOPs between any instructions that target the
    CfgExu, though you should be careful to place NOPs if the instruction
    following CFGSHIFTMASK is not a cfg instruction and it depends on the
    output of the calculation.

    Most CFG registers connect somewhere into the Tensix architecture and modify
    behaviour. Three CFG registers are specifically set aside to be
    'just registers', i.e. doesn't affect any architectural behaviour. These
    registers are called the 'CFG scratch registers', and any instructions that
    write to a CFG register can target them like any other.

    Every CFGSHIFTMASK uses one of the three scratch registers as an
    input operand; the scratch_sel field selects which one to use. The
    second operand (and also the output location) are specified with the
    CfgReg field. It is legal to target any* CFG register, including the
    scratch registers.

    *You can't access thread-private registers using this instruction. Also,
     the selected CFG register will be in the state pointed to by the current
     thread's state ID.

    The end result of running this instruction is equivalent to the following
    pseudocode:

      //CfgReg, right_cshift_amt, and mask_width are the arguments to this
      //instruction, as described above.
      //MM Oct 14 2022: Added op and disable_mask_on_old_val fields
      //circ_rshift() is a circular right-shift on 32-bit words
      extern uint32_t volatile *CFG; //Represents CFG register file

      uint32_t mask    = (((uint64_t)1 << (mask_width+1)) - 1) & 0xFFFFFFFF;
      uint32_t scratch_ind = (scratch_sel == 0b11) ? thread_id : scratch_sel;
      uint32_t scratch = CFG[SCRATCH_BASE + scratch_ind];

      uint32_t mask_shifted    = circ_rshift(mask,    right_cshift_amt);
      uint32_t scratch_shifted = circ_rshift(scratch, right_cshift_amt);

      uint32_t old_val = CFG[CfgReg];

      uint32_t old_val_masked =
        disable_mask_on_old_val
        ? old_val
        : old_val & ~mask_shifted
      ;

      switch(op) {
        case 0:
          CFG[CfgReg] = old_val_masked | (scratch_shifted & mask_shifted);
          break;

        case 1:
          CFG[CfgReg] = old_val_masked & (scratch_shifted & mask_shifted);
          break;

        case 2:
          CFG[CfgReg] = old_val_masked ^ (scratch_shifted & mask_shifted);
          break;

        case 3:
          CFG[CfgReg] = old_val_masked + (scratch_shifted & mask_shifted);
          break;
      }

    Example: We read some stream register, and want to put that register's bits
    23:6 into bits 29:12 of CFG register 41. That might look like this:

      TTI_STREAMWRCFG(SCRATCH_REG_INDEX, some_stream_reg, some_stream_id);
      TTI_CFGSHIFTMASK(0, 0, 32 -1, 6,       0b11, SCRATCH_REG_INDEX);  //Need to subtract 1 for mask width
      TTI_CFGSHIFTMASK(0, 0, 18 -1, 32 - 12, 0b11, 41);

    This first instruction reads some_stream_reg and saves the result
    into the scratch register. The first shiftmask uses a mask of all ones
    (for simplicity) and a circular right-shift of 6. We save the result
    back into the scratch reg; this is equivalent to cfg[scratch] >>= 6.
    The second shiftmask is what takes the lower 18 bits of the scratch
    register, shifts them left by 12 (note that a circular right-shift of
    32 - 12 is the same as a circular left-shift of 12), and overwrites
    that portion of cfg reg 41.


CFGSHIFTMASK_BUT_ALIAS_BIT_8_OF_CFG_REG_ADDR_WITH_LSB_OF_OPCODE:
  instrn_type: LOCAL_CREGS
  ex_resource: CFG
  ttsync_resource: CFG
  op_binary: 0xbb # = opcode(CFGSHIFTMASK) | 0b1
  # src_mask?
  # fcov?
  arguments: *CFGSHIFTMASK  # fixme: fcov from import
  description: ";-)"

COMMIT_SHADOW:
  instrn_type: OTHERS
  ex_resource: CFG
  ttsync_resource: SHADOW
  op_binary: 0x41
  fcov:
  arguments:
    - name: force_commit
      description: >
        Bit n of this field forces shadow register n to be committed. This is at the
        granularity of 128-bit words (otherwise we wouldn't have enough space in this
        instruction).
      start_bit: 0
      size: 20
      field_type: BIN
      fcov_point_bin_interval:
          bins: [ {name: "bot",      slice: "0x00001",  interval: ["0x0","0x0"]},
                  {name: "bot_half", slice: "0x80000",  interval: ["0x1","0x7FFFF"]},
                  {name: "top_half", slice: "0x80000",  interval: ["0x80000","0xFFFFF"]} ]
  description: >
    When a TRISC performs memory-mapped accesses to the CFG reg area, it gets cached
    in the shadow registers. Later on, the Tensix-TRISC sync will automatically commit
    shadow registers to live registers. However, if you have disabled it (or if you are
    doing something specific) you will need to manually commit shadow regs to live regs.
    This instruction will cause any cached values in the shadow regs to be committed to
    the live registers. Note that there is a chicken bit (swap_shadow_with_live_instead)
    that changes the behaviour of shadow reg commits.

MOP:
    op_binary: 0x1
    instrn_type: COMPUTE
    src_mask: 0x0
    ex_resource: SYNC
    ttsync_resource: MOP
    mop_only : 0x1
    fcov:
    description: "Macro-Op. Run template programmed into the MOP decoder. This instruction should never reach Tensix itself, but can only be pushed in through C kernels into MOP decoder."
    arguments:
      - name: zmask_lo8_or_loop_count
        start_bit: 0
        size: 15
        field_type: HEX
        description: "Low 8-bit zmask for unpacker loop;\n
                      9-bit Inner loop count for math/packer if non-zero value. Also lower 6-bits (bits[5:0]) of Outer loop count of math/packer if non-zero value - {Outer_loop_count[5:0], Inner_loop_count[8:0]}"
        fcov_point_bin_interval:
          bins: [ {name: "bot",      slice: "0x00001",  interval: ["0x0","0x0"]},
                  {name: "bot_half", slice: "0x10000",  interval: ["0x1","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]
      - name: loop_count
        start_bit: 15
        size: 7
        field_type: HEX
        description: "(loop count - 1) for unpacker loop MOP operation; \n
                      upper 4-bits (bits[9:6]) of Outer loop count for math/packer loop MOP operation if non-zero value"
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]
        # FIXME: implement more complex bins as per description
      - name: done
        start_bit: 22
        size: 1
        field_type: BIN
        description: "Indicates this is the last MOP opcode for the current mop_config bank and causes a bank switch when the MOP_CONFIG.sw_control bit is not set.\n
                      When MOP_CONFIG.sw_control is set, this field indicates which MOP config bank should be used for this MOP instruction"
        fcov_point_bool:
      - name: mop_type
        start_bit: 23
        size: 1
        field_type: BIN
        description: 0 - unpack z-mask loop, 1 - double math/unpack loop
        fcov_point_bool:

MOP_CFG:
    op_binary: 0x3
    instrn_type: COMPUTE
    ttsync_resource: OTHERS
    src_mask: 0x0
    ex_resource: SYNC
    fcov:
    mop_only : 0x1
    description: "Macro-op config op. Currently used to program the top 24 bits of Z-mask for unpacker loop."
    arguments:
      - name: zmask_hi24
        start_bit: 0
        size: 24
        field_type: HEX
        description: High 24-bit zmask for unpacker loop
        fcov_point_bin_interval:
          bins: [ {name: "bot_half", slice: "0x10000",  interval: ["0x0","0x7FFF"]},
                  {name: "top_half", slice: "0x10000",  interval: ["0x8000","0xFFFF"]} ]


REPLAY:
    op_binary: 0x4
    instrn_type: COMPUTE
    ex_resource: NONE
    ttsync_resource: REPLAY
    fcov:
    description: "Used to load or run instructions in the replay buffer. This instruction should never reach Tensix itself."
    arguments:
      - name: load_mode
        start_bit: 0
        size: 1
        field_type: BIN
        description: "If 1, the next len instructions will be saved to replay_buffer[start_idx +: len] AND WILL NOT REACH THE TENSIX CORE. If 0, this instruction will instead issue the instructions saved in replay_buffer[start_idx +: len] to the tensix core. "
        fcov_point_bool:
      - name: execute_while_loading
        start_bit: 1
        size: 1
        field_type: BIN
        fcov_point_bool:
        description: >
          When load_mode == 0, this bit has no effect.

          When load_mode == 1, we have:
            - When this bit is 1, instructions that are loaded into the replay buffer
              are also executed by the Tensix core (takes as many cycles as it would
              normally take to execute the loaded Tensix instructions)

            - When this bit is 0, instructions are only loaded into the replay buffer
              (guaranteed to take only one cycle per loaded Tensix instruction)
      - name: set_mutex
        start_bit: 2
        size: 1
        field_type: BIN
        description: "Set mutex for current replay bank to 1. This prevents future replay instructions from accessing that bank until SW releases it. SW can also poll this bit to see if it's safe to write."
        fcov_point_bins:
            bins: [ {name: "v00",  value: "0x0"},
                    {name: "v01",  value: "0x1"},
                    {name: "v10",  value: "0x2"} ]
      - name: last
        start_bit: 3
        size: 1
        field_type: BIN
        description: >
          The replay unit has double-banking support, meaning it is possible for you to be loading
          one bank while the other bank is being read. Use this bit in a load-replay instruction to
          indicate you want the next load-replay to write to the other bank. Use this bit in an
          execute-replay instruction to indicate that you want th next execute-replay instruction to
          read from the other bank. It is possible for writing and reading to be targeting the same
          bank. You must design your program carefully.
      - name: len # fixme: fcov
        start_bit: 4
        size: 10
        field_type: DEC
        description: "This field indicates how many replay buffer instructions are targeted by this replay command. The hardware will only use the log2(replay_buffer_depth) LSBs of this field."
      - name: start_idx # fixme: fcov
        start_bit: 14
        size: 10
        field_type: DEC
        description: "replay_buffer[start_idx +: len] are targeted by this replay command. The hardware will only use the log2(replay_buffer_depth) LSBs of this field."


RESOURCEDECL: # fixme: fcov
    op_binary: 0x5
    instrn_type: COMPUTE
    ex_resource: NONE
    ttsync_resource: OTHERS
    default_resources:
        # These entries are used by gen_tt_isntrn_resources_used
        # The target CFG space is all ones by default. These names
        # are designed to match the field names in the ttsync_rsrc_t
        # struct in tt_tensix_pkg.h
        GPR:      rd_gpr wr_gpr
        ATOMICS:  rd_gpr wr_gpr
        LDSTIND:  rd_gpr wr_gpr
        CFG:      rd_cfg wr_cfg
        STOREREG: rd_gpr
        LOADREG:  wr_gpr
        WRCFG:    rd_gpr wr_cfg
        RDCFG:    rd_cfg wr_gpr
        RV_WRCFG: wr_cfg
        UNPACK:   rd_cfg
        PACK:     rd_cfg
        SHADOW:   rd_cfg wr_cfg # You probably want this correctly ordered against your MMIO accesses
        MOP:      rd_cfg wr_cfg rd_gpr wr_gpr # Assume everything. Programmer needs to inform us
        REPLAY:   rd_cfg wr_cfg rd_gpr wr_gpr # Assume everything. Programmer needs to inform us
        OTHERS:   rd_cfg

    description: >
        Declare resources ahead-of-time for a given class of Tensix
        instructions. If not performed, the hardware will use the
        default values shown below.
        Once set, the declared resources are persistent.
    arguments:
      - name: op_class # Couldn't name this "class" because C++ choked on the generated code
        start_bit: 0
        size: 5
        field_type: DEC
        description: >
            Select the class number whose resources you want to edit. The
            mapping from classes to class numbers is auto-generated TODO
            I have yet to finish the script to generate nice symbolic
            values in ckernel.h or something, so for now you'll have to
            look at the generated RTL for tt_instrn_resources_used.sv to
            figure it out

            Please note: a MOP/REPLAY  template can contain
            instructions from arbitrary classes. The Tensix-TRISC sync
            mechanism will NOT consult the resources declared for those
            particular classes. Instead, all instructions generated by
            the MOP/REPLAY decoder will be under the auspices of the
            parent MOP/REPLAY instruction, and as such, are treated as
            if they use the resources declared for that parent
            instruction. It is up to the programmer to set the
            MOP/REPLAY resources ahead of time.
      - name: resources
        start_bit: 5
        size: 10
        field_type: BIN
        description: >
          Resources declared for the instruction class targeted by the
          op_class field. This must match the definition of ttsync_rsrc_t
          in tt_tensix_pkg.sv
      - name: linger_time
        start_bit: 15
        size: 4
        end_bit: 18
        field_type: BIN
        description: >
          TL;DR
          -----
          If a Tensix instrn was stalled, then after the RISC memory-mapped access goes through this
          'linger time' is copied to a shift register. This shift registers is shifted to the right
          (i.e. from MSB to LSB) on every cycle. We will keep stalling the Tensix instrn until the
          shift register's value reaches zero. It is legal to have a linger_time value of 0. The
          default value is 4'b0001.


          DETAILS
          -------
          Every instruction class can optionally add extra 'linger time' after the ibuffer is stalled.
          In other words, suppose there is a RISC memory-mapped register access that is keeping a
          Tensix instruction stalled: in some cases, we might not want the instruction to suddenly
          issue on the cycle right after the register access goes through (no particular examples come
          to mind, but this feature is to try and add options in case the default linger time doesn't
          work in all cases!)

          This is NOT interpreted as a cycle count! Instead, it is OR'ed into a shift register whenever
          the current Tensix instruction is stalled (it's done this way to simplify the RTL; so sue me).

          Example:

          t = 0: suppose the head of the RQ is stalled because we're waiting for a register access to go
          through. The ibuffer stall signal is raised because there is a stall condition. Also, the
          linger time for the class of the currently stalled Tensix instruction will be OR'ed into a shift
          register at the next rising edge. Suppose also that the register access is issued on this cycle
          (meaning that the LSQ entry will be popped at the next rising edge).

          //(These aren't the actual RTL signal names)
          LSQ_stalls_ibuffer = 1  //<- There is currently an LSQ entry that is stalling the current Tensix instrn
          LSQ_read_enable = 1     //<- On the next clock edge, the register access in the LSQ will be issued
          shift_register = 0b0000 //<- Initial shift register value
          o_ibuffer_stall = 1    //<- This wire is routed to the ibuffer and causes the current Tensix instrn to stall


          t = 1: The register access is done, so there is no more stall condition. However, the shift register
          had a value written into it. As long as this shift register is nonzero,  we will continue to stall
          the current Tensix instrn

          LSQ_stalls_ibuffer = 0  //<- There are no LSQ entries causing the current Tensix isntrn (if any) to stall
          LSQ_read_enable = 0
          shift_register = 0b0100 //<- Suppose the Tensix instrn stalled in t=0 wanted a linger time of 3 cycles
          o_ibuffer_stall = 1     //<- We will still stall the same Tensix instrn that was stalled in t=0


          t = 2: The shift register shifts down by one. It is still not zero, so we keep stalling the instrn

          LSQ_stalls_ibuffer = 0
          LSQ_read_enable = 0
          shift_register = 0b0010
          o_ibuffer_stall = 1


          t = 3: The shift register shifts down by one. It is still not zero, so we keep stalling the instrn

          LSQ_stalls_ibuffer = 0
          LSQ_read_enable = 0
          shift_register = 0b0001
          o_ibuffer_stall = 1


          t = 3: The shift register shifts down by one. It is still zero, so we lower the ibuffer stall signal.
          The instrn will be issued on the next clock edge

          LSQ_stalls_ibuffer = 0
          LSQ_read_enable = 0
          shift_register = 0b0000
          o_ibuffer_stall = 0

          It is legal to have a linger_time value of 0 (this means the instruction is only stalled while there
          is a conflicting access in the LSQ).
